using System.Runtime.CompilerServices;

namespace Paradise.ECS;

/// <summary>
/// A world wrapper that provides tag support for entities.
/// Tags are stored as a component (EntityTags) that is automatically added to spawned entities.
/// </summary>
/// <typeparam name="TBits">The bit storage type for component masks.</typeparam>
/// <typeparam name="TRegistry">The component registry type.</typeparam>
/// <typeparam name="TConfig">The world configuration type.</typeparam>
/// <typeparam name="TEntityTags">The EntityTags component type (generated by TagGenerator).</typeparam>
/// <typeparam name="TTagMask">The tag mask type (generated by TagGenerator as TagMask alias).</typeparam>
/// <remarks>
/// TaggedWorld wraps a standard World and adds tag-specific APIs.
/// Tags are stored in a per-entity bitmask component, enabling O(1) tag operations
/// without archetype changes.
/// </remarks>
public sealed class TaggedWorld<TBits, TRegistry, TConfig, TEntityTags, TTagMask>
    where TBits : unmanaged, IStorage
    where TRegistry : IComponentRegistry
    where TConfig : IConfig, new()
    where TEntityTags : unmanaged, IComponent, IEntityTags<TTagMask>
    where TTagMask : unmanaged, IBitSet<TTagMask>
{
    private readonly World<TBits, TRegistry, TConfig> _world;
    private readonly ChunkTagRegistry<TTagMask> _chunkTagRegistry;

    public TaggedWorld(World<TBits, TRegistry, TConfig> world, ChunkTagRegistry<TTagMask> chunkTagRegistry)
    {
        _world = world;
        _chunkTagRegistry = chunkTagRegistry;
    }

    /// <summary>
    /// Gets the underlying World instance.
    /// </summary>
    public World<TBits, TRegistry, TConfig> World => _world;

    /// <summary>
    /// Gets the archetype registry for this world.
    /// </summary>
    public ArchetypeRegistry<TBits, TRegistry, TConfig> ArchetypeRegistry => _world.Registry;

    /// <summary>
    /// Gets the chunk tag registry for per-chunk tag filtering.
    /// </summary>
    public ChunkTagRegistry<TTagMask> ChunkTagRegistry => _chunkTagRegistry;

    /// <summary>
    /// Gets the current number of live entities.
    /// </summary>
    public int EntityCount => _world.EntityCount;

    /// <summary>
    /// Spawns a new entity with the EntityTags component automatically added.
    /// </summary>
    /// <returns>The newly created entity.</returns>
    public Entity Spawn()
    {
        var entity = _world.Spawn();
        _world.AddComponent<TEntityTags>(entity, default);
        return entity;
    }

    /// <summary>
    /// Despawns an entity, removing it from the world.
    /// </summary>
    /// <param name="entity">The entity to despawn.</param>
    public void Despawn(Entity entity)
    {
        // Capture location before despawn for chunk tag registry update
        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        var chunkHandle = archetype.GetChunk(chunkIndex);

        // Despawn the entity
        _world.Despawn(entity);

        // Recompute chunk tag mask (entity was removed, chunk mask may need updating)
        RecomputeChunkMask(chunkHandle, archetype, chunkIndex);
    }

    /// <summary>
    /// Checks if an entity is still alive.
    /// </summary>
    /// <param name="entity">The entity to check.</param>
    /// <returns>True if the entity is alive.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsAlive(Entity entity) => _world.IsAlive(entity);

    /// <summary>
    /// Adds a tag to an entity.
    /// </summary>
    /// <typeparam name="TTag">The tag type to add.</typeparam>
    /// <param name="entity">The entity to add the tag to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        tags.Mask = tags.Mask.Set(TTag.TagId);

        // Update chunk tag mask (OR the tag bit into the chunk's mask)
        var tagBit = default(TTagMask).Set(TTag.TagId);
        var chunkHandle = GetEntityChunkHandle(entity);
        _chunkTagRegistry.OrChunkMask(chunkHandle, tagBit);
    }

    /// <summary>
    /// Removes a tag from an entity.
    /// </summary>
    /// <typeparam name="TTag">The tag type to remove.</typeparam>
    /// <param name="entity">The entity to remove the tag from.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        tags.Mask = tags.Mask.Clear(TTag.TagId);

        // Recompute chunk tag mask (since we removed a tag, the chunk mask may need updating)
        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        var chunkHandle = archetype.GetChunk(chunkIndex);
        RecomputeChunkMask(chunkHandle, archetype, chunkIndex);
    }

    /// <summary>
    /// Checks if an entity has a specific tag.
    /// </summary>
    /// <typeparam name="TTag">The tag type to check.</typeparam>
    /// <param name="entity">The entity to check.</param>
    /// <returns>True if the entity has the tag.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasTag<TTag>(Entity entity) where TTag : ITag
    {
        var tags = _world.GetComponent<TEntityTags>(entity);
        return tags.Mask.Get(TTag.TagId);
    }

    /// <summary>
    /// Gets the full tag mask for an entity.
    /// </summary>
    /// <param name="entity">The entity to get tags from.</param>
    /// <returns>The tag mask.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TTagMask GetTags(Entity entity)
    {
        return _world.GetComponent<TEntityTags>(entity).Mask;
    }

    /// <summary>
    /// Sets the full tag mask for an entity.
    /// </summary>
    /// <param name="entity">The entity to set tags on.</param>
    /// <param name="tags">The tag mask to set.</param>
    public void SetTags(Entity entity, TTagMask tags)
    {
        ref var entityTags = ref _world.GetComponentRef<TEntityTags>(entity);
        var oldMask = entityTags.Mask;
        entityTags.Mask = tags;

        // If tags changed, we need to update the chunk mask
        var addedTags = tags.AndNot(oldMask);   // tags in new but not in old
        var removedTags = oldMask.AndNot(tags); // tags in old but not in new

        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        var chunkHandle = archetype.GetChunk(chunkIndex);

        if (!addedTags.Equals(default(TTagMask)))
        {
            // OR the new tags into the chunk mask
            _chunkTagRegistry.OrChunkMask(chunkHandle, addedTags);
        }

        if (!removedTags.Equals(default(TTagMask)))
        {
            // Recompute chunk mask since tags were removed
            RecomputeChunkMask(chunkHandle, archetype, chunkIndex);
        }
    }

    /// <summary>
    /// Gets a component value from an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T GetComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.GetComponent<T>(entity);

    /// <summary>
    /// Gets a reference to a component on an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref T GetComponentRef<T>(Entity entity) where T : unmanaged, IComponent
        => ref _world.GetComponentRef<T>(entity);

    /// <summary>
    /// Sets a component value on an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetComponent<T>(Entity entity, T value) where T : unmanaged, IComponent
        => _world.SetComponent(entity, value);

    /// <summary>
    /// Checks if an entity has a component.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.HasComponent<T>(entity);

    /// <summary>
    /// Adds a component to an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddComponent<T>(Entity entity, T value = default) where T : unmanaged, IComponent
        => _world.AddComponent(entity, value);

    /// <summary>
    /// Removes a component from an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.RemoveComponent<T>(entity);

    /// <summary>
    /// Gets the chunk handle for an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ChunkHandle GetEntityChunkHandle(Entity entity)
    {
        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        return archetype.GetChunk(chunkIndex);
    }

    /// <summary>
    /// Recomputes the chunk tag mask by OR-ing all entity tag masks in the chunk.
    /// </summary>
    /// <param name="chunkHandle">The chunk handle.</param>
    /// <param name="archetype">The archetype containing the chunk.</param>
    /// <param name="chunkIndex">The chunk index within the archetype.</param>
    private void RecomputeChunkMask(ChunkHandle chunkHandle, Archetype<TBits, TRegistry, TConfig> archetype, int chunkIndex)
    {
        var newMask = default(TTagMask);

        // Calculate how many entities are in this specific chunk
        int entitiesPerChunk = archetype.Layout.EntitiesPerChunk;
        int totalEntities = archetype.EntityCount;
        int entityCountInChunk;

        if ((chunkIndex + 1) * entitiesPerChunk <= totalEntities)
        {
            // Full chunk
            entityCountInChunk = entitiesPerChunk;
        }
        else
        {
            // Last chunk (partially filled)
            entityCountInChunk = totalEntities - chunkIndex * entitiesPerChunk;
        }

        if (entityCountInChunk <= 0)
        {
            _chunkTagRegistry.SetChunkMask(chunkHandle, default);
            return;
        }

        // Get chunk data and compute union of all entity tag masks
        var bytes = _world.ChunkManager.GetBytes(chunkHandle);
        int baseOffset = archetype.Layout.GetBaseOffset<TEntityTags>();
        int entityTagsSize = TRegistry.TypeInfos[TEntityTags.TypeId.Value].Size;

        for (int i = 0; i < entityCountInChunk; i++)
        {
            ref var entityTags = ref bytes.GetRef<TEntityTags>(baseOffset + i * entityTagsSize);
            newMask = newMask.Or(entityTags.Mask);
        }

        _chunkTagRegistry.SetChunkMask(chunkHandle, newMask);
    }
}

/// <summary>
/// Interface for EntityTags component to access the tag mask.
/// </summary>
/// <typeparam name="TTagMask">The tag mask type.</typeparam>
public interface IEntityTags<TTagMask>
    where TTagMask : unmanaged, IBitSet<TTagMask>
{
    /// <summary>
    /// Gets or sets the tag mask for this entity.
    /// </summary>
    TTagMask Mask { get; set; }
}
