using System.Runtime.CompilerServices;

namespace Paradise.ECS;

/// <summary>
/// A world wrapper that provides tag support for entities.
/// Tags are stored as a component (EntityTags) that is automatically added to spawned entities.
/// </summary>
/// <typeparam name="TBits">The bit storage type for component masks.</typeparam>
/// <typeparam name="TRegistry">The component registry type.</typeparam>
/// <typeparam name="TConfig">The world configuration type.</typeparam>
/// <typeparam name="TEntityTags">The EntityTags component type (generated by TagGenerator).</typeparam>
/// <typeparam name="TTagMask">The tag mask type (generated by TagGenerator as TagMask alias).</typeparam>
/// <remarks>
/// TaggedWorld wraps a standard World and adds tag-specific APIs.
/// Tags are stored in a per-entity bitmask component, enabling O(1) tag operations
/// without archetype changes.
/// </remarks>
public sealed class TaggedWorld<TBits, TRegistry, TConfig, TEntityTags, TTagMask> : IDisposable
    where TBits : unmanaged, IStorage
    where TRegistry : IComponentRegistry
    where TConfig : IConfig, new()
    where TEntityTags : unmanaged, IComponent, IEntityTags<TTagMask>
    where TTagMask : unmanaged, IBitSet<TTagMask>
{
    private readonly ChunkManager _chunkManager;
    private readonly SharedArchetypeMetadata<TBits, TRegistry, TConfig> _sharedMetadata;
    private readonly World<TBits, TRegistry, TConfig> _world;
    private readonly ChunkTagRegistry<TTagMask> _chunkTagRegistry;
    private bool _disposed;

    /// <summary>
    /// Creates a new TaggedWorld with all subsystems using default configuration.
    /// </summary>
    public TaggedWorld() : this(new TConfig())
    {
    }

    /// <summary>
    /// Creates a new TaggedWorld with all subsystems using the specified configuration.
    /// </summary>
    /// <param name="config">The configuration instance.</param>
    public TaggedWorld(TConfig config)
    {
        _chunkManager = ChunkManager.Create(config);
        _sharedMetadata = new SharedArchetypeMetadata<TBits, TRegistry, TConfig>(config);
        _world = new World<TBits, TRegistry, TConfig>(config, _sharedMetadata, _chunkManager);
        _chunkTagRegistry = new ChunkTagRegistry<TTagMask>(
            config.ChunkAllocator,
            TConfig.MaxMetaBlocks,
            TConfig.ChunkSize);
    }

    /// <summary>
    /// Gets the underlying World instance.
    /// </summary>
    public World<TBits, TRegistry, TConfig> World => _world;

    /// <summary>
    /// Gets the archetype registry for this world.
    /// </summary>
    public ArchetypeRegistry<TBits, TRegistry, TConfig> ArchetypeRegistry => _world.Registry;

    /// <summary>
    /// Gets the chunk tag registry for per-chunk tag filtering.
    /// </summary>
    public ChunkTagRegistry<TTagMask> ChunkTagRegistry => _chunkTagRegistry;

    /// <summary>
    /// Gets the current number of live entities.
    /// </summary>
    public int EntityCount => _world.EntityCount;

    /// <summary>
    /// Spawns a new entity with the EntityTags component automatically added.
    /// </summary>
    /// <returns>The newly created entity.</returns>
    public Entity Spawn()
    {
        var entity = _world.Spawn();
        _world.AddComponent<TEntityTags>(entity, default);
        return entity;
    }

    /// <summary>
    /// Despawns an entity, removing it from the world.
    /// </summary>
    /// <param name="entity">The entity to despawn.</param>
    /// <returns>True if the entity was despawned; false if it was already dead.</returns>
    public bool Despawn(Entity entity)
    {
        if (!_world.IsAlive(entity))
            return false;

        // Capture location before despawn for chunk tag registry update
        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        var chunkHandle = archetype.GetChunk(chunkIndex);

        // Check if entity has EntityTags component (entities created via EntityBuilder may not have it)
        var hasEntityTags = archetype.Layout.HasComponent<TEntityTags>();

        // Despawn the entity
        _world.Despawn(entity);

        // Recompute chunk tag mask only if the archetype had EntityTags
        if (hasEntityTags)
        {
            RecomputeChunkMask(chunkHandle, archetype, chunkIndex);
        }

        return true;
    }

    /// <summary>
    /// Clears all entities from the world.
    /// Also clears all chunk tag masks.
    /// </summary>
    public void Clear()
    {
        _world.Clear();
        _chunkTagRegistry.Clear();
    }

    /// <summary>
    /// Disposes of all owned resources (ChunkManager, SharedArchetypeMetadata, ChunkTagRegistry).
    /// </summary>
    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        _chunkTagRegistry.Dispose();
        _sharedMetadata.Dispose();
        _chunkManager.Dispose();
    }

    /// <summary>
    /// Checks if an entity is still alive.
    /// </summary>
    /// <param name="entity">The entity to check.</param>
    /// <returns>True if the entity is alive.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsAlive(Entity entity) => _world.IsAlive(entity);

    /// <summary>
    /// Adds a tag to an entity.
    /// </summary>
    /// <typeparam name="TTag">The tag type to add.</typeparam>
    /// <param name="entity">The entity to add the tag to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        tags.Mask = tags.Mask.Set(TTag.TagId);

        // Update chunk tag mask (OR the tag bit into the chunk's mask)
        var tagBit = default(TTagMask).Set(TTag.TagId);
        var chunkHandle = GetEntityChunkHandle(entity);
        _chunkTagRegistry.OrChunkMask(chunkHandle, tagBit);
    }

    /// <summary>
    /// Removes a tag from an entity.
    /// </summary>
    /// <typeparam name="TTag">The tag type to remove.</typeparam>
    /// <param name="entity">The entity to remove the tag from.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        tags.Mask = tags.Mask.Clear(TTag.TagId);

        // Recompute chunk tag mask (since we removed a tag, the chunk mask may need updating)
        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        var chunkHandle = archetype.GetChunk(chunkIndex);
        RecomputeChunkMask(chunkHandle, archetype, chunkIndex);
    }

    /// <summary>
    /// Checks if an entity has a specific tag.
    /// </summary>
    /// <typeparam name="TTag">The tag type to check.</typeparam>
    /// <param name="entity">The entity to check.</param>
    /// <returns>True if the entity has the tag.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        return tags.Mask.Get(TTag.TagId);
    }

    /// <summary>
    /// Gets the full tag mask for an entity.
    /// </summary>
    /// <param name="entity">The entity to get tags from.</param>
    /// <returns>The tag mask.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TTagMask GetTags(Entity entity)
    {
        return _world.GetComponent<TEntityTags>(entity).Mask;
    }

    /// <summary>
    /// Sets the full tag mask for an entity.
    /// </summary>
    /// <param name="entity">The entity to set tags on.</param>
    /// <param name="tags">The tag mask to set.</param>
    public void SetTags(Entity entity, TTagMask tags)
    {
        ref var entityTags = ref _world.GetComponentRef<TEntityTags>(entity);
        var oldMask = entityTags.Mask;
        entityTags.Mask = tags;

        // If tags changed, we need to update the chunk mask
        var addedTags = tags.AndNot(oldMask);   // tags in new but not in old
        var removedTags = oldMask.AndNot(tags); // tags in old but not in new

        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        var chunkHandle = archetype.GetChunk(chunkIndex);

        if (!addedTags.Equals(default(TTagMask)))
        {
            // OR the new tags into the chunk mask
            _chunkTagRegistry.OrChunkMask(chunkHandle, addedTags);
        }

        if (!removedTags.Equals(default(TTagMask)))
        {
            // Recompute chunk mask since tags were removed
            RecomputeChunkMask(chunkHandle, archetype, chunkIndex);
        }
    }

    /// <summary>
    /// Gets a component value from an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T GetComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.GetComponent<T>(entity);

    /// <summary>
    /// Gets a reference to a component on an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref T GetComponentRef<T>(Entity entity) where T : unmanaged, IComponent
        => ref _world.GetComponentRef<T>(entity);

    /// <summary>
    /// Sets a component value on an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetComponent<T>(Entity entity, T value) where T : unmanaged, IComponent
        => _world.SetComponent(entity, value);

    /// <summary>
    /// Checks if an entity has a component.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.HasComponent<T>(entity);

    /// <summary>
    /// Adds a component to an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddComponent<T>(Entity entity, T value = default) where T : unmanaged, IComponent
        => _world.AddComponent(entity, value);

    /// <summary>
    /// Removes a component from an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.RemoveComponent<T>(entity);

    /// <summary>
    /// Creates a new query builder bound to this world.
    /// Use this for building tag-filtered queries with a clean API.
    /// </summary>
    /// <returns>A query builder bound to this world's type parameters.</returns>
    /// <example>
    /// <code>
    /// // Clean API - only specify the tag type
    /// var query = world.Query().WithTag&lt;EnemyTag&gt;().With&lt;Position&gt;().Build();
    /// foreach (var entity in query) { ... }
    /// </code>
    /// </example>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TaggedWorldQueryBuilder<TBits, TRegistry, TConfig, TEntityTags, TTagMask> Query()
        => new(this);

    /// <summary>
    /// Gets the chunk handle for an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ChunkHandle GetEntityChunkHandle(Entity entity)
    {
        var location = _world.GetLocation(entity);
        var archetype = _world.Registry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        return archetype.GetChunk(chunkIndex);
    }

    /// <summary>
    /// Recomputes the chunk tag mask by OR-ing all entity tag masks in the chunk.
    /// </summary>
    /// <param name="chunkHandle">The chunk handle.</param>
    /// <param name="archetype">The archetype containing the chunk.</param>
    /// <param name="chunkIndex">The chunk index within the archetype.</param>
    private void RecomputeChunkMask(ChunkHandle chunkHandle, Archetype<TBits, TRegistry, TConfig> archetype, int chunkIndex)
    {
        var newMask = default(TTagMask);

        // Calculate how many entities are in this specific chunk
        int entitiesPerChunk = archetype.Layout.EntitiesPerChunk;
        int totalEntities = archetype.EntityCount;
        int entityCountInChunk;

        if ((chunkIndex + 1) * entitiesPerChunk <= totalEntities)
        {
            // Full chunk
            entityCountInChunk = entitiesPerChunk;
        }
        else
        {
            // Last chunk (partially filled)
            entityCountInChunk = totalEntities - chunkIndex * entitiesPerChunk;
        }

        if (entityCountInChunk <= 0)
        {
            _chunkTagRegistry.SetChunkMask(chunkHandle, default);
            return;
        }

        // Get chunk data and compute union of all entity tag masks
        var bytes = _world.ChunkManager.GetBytes(chunkHandle);
        int baseOffset = archetype.Layout.GetBaseOffset<TEntityTags>();
        int entityTagsSize = TRegistry.TypeInfos[TEntityTags.TypeId.Value].Size;

        for (int i = 0; i < entityCountInChunk; i++)
        {
            ref var entityTags = ref bytes.GetRef<TEntityTags>(baseOffset + i * entityTagsSize);
            newMask = newMask.Or(entityTags.Mask);
        }

        _chunkTagRegistry.SetChunkMask(chunkHandle, newMask);
    }
}

/// <summary>
/// Extension methods for building queries in a TaggedWorld.
/// </summary>
public static class QueryBuilderTaggedWorldExtensions
{
    extension<TBits>(QueryBuilder<TBits> builder) where TBits : unmanaged, IStorage
    {
        /// <summary>
        /// Builds a WorldQuery from this description for a TaggedWorld.
        /// Delegates to the underlying World.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WorldQuery<TBits, TRegistry, TConfig> Build<TRegistry, TConfig, TEntityTags, TTagMask>(
            TaggedWorld<TBits, TRegistry, TConfig, TEntityTags, TTagMask> taggedWorld)
            where TRegistry : IComponentRegistry
            where TConfig : IConfig, new()
            where TEntityTags : unmanaged, IComponent, IEntityTags<TTagMask>
            where TTagMask : unmanaged, IBitSet<TTagMask>
        {
            return builder.Build(taggedWorld.World);
        }

        /// <summary>
        /// Builds a WorldChunkQuery from this description for a TaggedWorld.
        /// Delegates to the underlying World.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WorldChunkQuery<TBits, TRegistry, TConfig> BuildChunk<TRegistry, TConfig, TEntityTags, TTagMask>(
            TaggedWorld<TBits, TRegistry, TConfig, TEntityTags, TTagMask> taggedWorld)
            where TRegistry : IComponentRegistry
            where TConfig : IConfig, new()
            where TEntityTags : unmanaged, IComponent, IEntityTags<TTagMask>
            where TTagMask : unmanaged, IBitSet<TTagMask>
        {
            return builder.BuildChunk(taggedWorld.World);
        }
    }
}

