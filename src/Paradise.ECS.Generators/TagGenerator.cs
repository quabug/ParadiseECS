using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Paradise.ECS.Generators;

/// <summary>
/// Source generator that processes [Tag] attributes and generates:
/// - Tag partial structs with ITag interface
/// - TagRegistry for runtime tag ID mapping
/// - TagAliases for TagMask type alias
/// - EntityTags component with IEntityTags interface
/// </summary>
[Generator]
public class TagGenerator : IIncrementalGenerator
{
    private const string TagAttributeFullName = "Paradise.ECS.TagAttribute";
    private const string ComponentAttributeFullName = "Paradise.ECS.ComponentAttribute";
    private const string RegistryNamespaceAttributeFullName = "Paradise.ECS.ComponentRegistryNamespaceAttribute";
    private const int DefaultMaxTagId = (1 << 11) - 1;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var tagTypes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                TagAttributeFullName,
                predicate: static (node, _) => node is StructDeclarationSyntax,
                transform: static (ctx, _) => GeneratorUtilities.ExtractTypeInfo(ctx, TypeKind.Tag))
            .Where(static x => x.HasValue)
            .Select(static (x, _) => x!.Value);

        // Collect components to check for user-defined EntityTags
        var componentTypes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                ComponentAttributeFullName,
                predicate: static (node, _) => node is StructDeclarationSyntax,
                transform: static (ctx, _) => GeneratorUtilities.ExtractTypeInfo(ctx, TypeKind.Component))
            .Where(static x => x.HasValue)
            .Select(static (x, _) => x!.Value);

        var config = context.CompilationProvider
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select(static (pair, _) => ExtractConfig(pair.Left, pair.Right));

        var combined = tagTypes.Collect()
            .Combine(componentTypes.Collect())
            .Combine(config);

        context.RegisterSourceOutput(combined, static (ctx, data) =>
            GenerateTagCode(ctx, data.Left.Left, data.Left.Right, data.Right));
    }

    private static TagGeneratorConfig ExtractConfig(Compilation compilation, AnalyzerConfigOptionsProvider options)
    {
        // Root namespace: attribute > build property > default
        var nsAttr = compilation.Assembly.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == RegistryNamespaceAttributeFullName);
        var rootNamespace = nsAttr?.ConstructorArguments.FirstOrDefault().Value as string;
        if (rootNamespace == null)
        {
            options.GlobalOptions.TryGetValue("build_property.RootNamespace", out rootNamespace);
            rootNamespace ??= "Paradise.ECS";
        }

        return new TagGeneratorConfig(rootNamespace);
    }

    private static void GenerateTagCode(
        SourceProductionContext context,
        ImmutableArray<TypeInfo> tags,
        ImmutableArray<TypeInfo> components,
        TagGeneratorConfig config)
    {
        // Process and validate tags
        var (validTags, tagMaskType) = GeneratorUtilities.ProcessTypes(
            context, tags, DefaultMaxTagId,
            DiagnosticDescriptors.TagNotUnmanaged,
            DiagnosticDescriptors.InvalidTagGuidFormat,
            DiagnosticDescriptors.UnsupportedTagContainingType,
            DiagnosticDescriptors.TagIdExceedsLimit,
            DiagnosticDescriptors.DuplicateTagId,
            t => t.HasInstanceFields ? DiagnosticDescriptors.TagHasFields : null);

        if (validTags.Count == 0)
            return;

        // Generate tag partial structs
        foreach (var tag in validTags)
            GenerateTagPartialStruct(context, tag);

        // Generate TagRegistry
        GenerateTagRegistry(context, validTags, config.RootNamespace);

        // Generate TagAliases
        GenerateTagAliases(context, validTags.Count, tagMaskType);

        // Check for user-defined EntityTags in the root namespace
        var expectedEntityTagsFqn = $"{config.RootNamespace}.EntityTags";
        var userDefinedEntityTags = components.Any(c => c.FullyQualifiedName == expectedEntityTagsFqn);

        // Generate EntityTags component (partial if user-defined, complete otherwise)
        GenerateEntityTagsComponent(context, config.RootNamespace, tagMaskType, userDefinedEntityTags);
    }

    private static void GenerateTagPartialStruct(SourceProductionContext context, TypeInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CA1708 // Identifiers should differ by more than case");
        sb.AppendLine();

        if (info.Namespace != null)
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        var indent = "";
        foreach (var ct in info.ContainingTypes)
        {
            sb.AppendLine($"{indent}partial {ct.Keyword} {ct.Name}");
            sb.AppendLine($"{indent}{{");
            indent += "    ";
        }

        if (info.Guid != null)
            sb.AppendLine($"{indent}[global::System.Runtime.InteropServices.Guid(\"{info.Guid}\")]");

        sb.AppendLine($"{indent}partial struct {info.TypeName} : global::Paradise.ECS.ITag");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    /// <summary>The unique tag type ID assigned at module initialization.</summary>");
        sb.AppendLine($"{indent}    public static global::Paradise.ECS.TagId TagId {{ get; internal set; }} = global::Paradise.ECS.TagId.Invalid;");
        sb.AppendLine();
        sb.AppendLine($"{indent}    /// <summary>The stable GUID for this tag type.</summary>");
        sb.AppendLine(info.Guid != null
            ? $"{indent}    public static global::System.Guid Guid {{ get; }} = new global::System.Guid(\"{info.Guid}\");"
            : $"{indent}    public static global::System.Guid Guid => global::System.Guid.Empty;");
        sb.AppendLine($"{indent}}}");

        for (int i = info.ContainingTypes.Length - 1; i >= 0; i--)
            sb.AppendLine($"{new string(' ', i * 4)}}}");

        var filename = $"Tag_{info.FullyQualifiedName.Replace(".", "_").Replace("+", "_")}.g.cs";
        context.AddSource(filename, sb.ToString());
    }

    private static void GenerateTagRegistry(SourceProductionContext context, List<TypeInfo> tags, string rootNamespace)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {rootNamespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>Provides runtime Type-to-TagId mapping for all registered tags.</summary>");
        sb.AppendLine("public static class TagRegistry");
        sb.AppendLine("{");
        sb.AppendLine("    private static global::System.Collections.Frozen.FrozenDictionary<global::System.Type, global::Paradise.ECS.TagId>? s_typeToId;");
        sb.AppendLine("    private static global::System.Collections.Frozen.FrozenDictionary<global::System.Guid, global::Paradise.ECS.TagId>? s_guidToId;");
        sb.AppendLine();
        sb.AppendLine("    [global::System.Runtime.CompilerServices.ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        var tags = new (global::System.Type Type, global::System.Guid Guid, int ManualId, global::System.Action<global::Paradise.ECS.TagId> SetId)[]");
        sb.AppendLine("        {");

        foreach (var tag in tags)
        {
            var guid = tag.Guid != null ? $"new global::System.Guid(\"{tag.Guid}\")" : "global::System.Guid.Empty";
            var manualId = tag.ManualId?.ToString(System.Globalization.CultureInfo.InvariantCulture) ?? "-1";
            sb.AppendLine($"            (typeof(global::{tag.FullyQualifiedName}), {guid}, {manualId}, (global::Paradise.ECS.TagId id) => global::{tag.FullyQualifiedName}.TagId = id),");
        }

        sb.AppendLine("        };");
        sb.AppendLine();
        sb.AppendLine("        var typeToId = new global::System.Collections.Generic.Dictionary<global::System.Type, global::Paradise.ECS.TagId>(tags.Length);");
        sb.AppendLine("        var guidToId = new global::System.Collections.Generic.Dictionary<global::System.Guid, global::Paradise.ECS.TagId>();");
        sb.AppendLine("        var usedIds = new global::System.Collections.Generic.HashSet<int>();");
        sb.AppendLine();
        sb.AppendLine("        foreach (var tag in tags)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (tag.ManualId >= 0)");
        sb.AppendLine("            {");
        sb.AppendLine("                var id = new global::Paradise.ECS.TagId(tag.ManualId);");
        sb.AppendLine("                tag.SetId(id);");
        sb.AppendLine("                typeToId[tag.Type] = id;");
        sb.AppendLine("                if (tag.Guid != global::System.Guid.Empty) guidToId[tag.Guid] = id;");
        sb.AppendLine("                usedIds.Add(tag.ManualId);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        var autoTags = global::System.Linq.Enumerable.ToList(global::System.Linq.Enumerable.Where(tags, t => t.ManualId < 0));");
        sb.AppendLine("        int nextId = 0;");
        sb.AppendLine("        foreach (var tag in autoTags)");
        sb.AppendLine("        {");
        sb.AppendLine("            while (usedIds.Contains(nextId)) nextId++;");
        sb.AppendLine("            var id = new global::Paradise.ECS.TagId(nextId);");
        sb.AppendLine("            tag.SetId(id);");
        sb.AppendLine("            typeToId[tag.Type] = id;");
        sb.AppendLine("            if (tag.Guid != global::System.Guid.Empty) guidToId[tag.Guid] = id;");
        sb.AppendLine("            usedIds.Add(nextId);");
        sb.AppendLine("            nextId++;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        s_typeToId = global::System.Collections.Frozen.FrozenDictionary.ToFrozenDictionary(typeToId);");
        sb.AppendLine("        s_guidToId = global::System.Collections.Frozen.FrozenDictionary.ToFrozenDictionary(guidToId);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static global::Paradise.ECS.TagId GetId(global::System.Type type) =>");
        sb.AppendLine("        s_typeToId!.TryGetValue(type, out var id) ? id : global::Paradise.ECS.TagId.Invalid;");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetId(global::System.Type type, out global::Paradise.ECS.TagId id) =>");
        sb.AppendLine("        s_typeToId!.TryGetValue(type, out id);");
        sb.AppendLine();
        sb.AppendLine("    public static global::Paradise.ECS.TagId GetId(global::System.Guid guid) =>");
        sb.AppendLine("        s_guidToId!.TryGetValue(guid, out var id) ? id : global::Paradise.ECS.TagId.Invalid;");
        sb.AppendLine();
        sb.AppendLine("    public static bool TryGetId(global::System.Guid guid, out global::Paradise.ECS.TagId id) =>");
        sb.AppendLine("        s_guidToId!.TryGetValue(guid, out id);");
        sb.AppendLine("}");

        context.AddSource("TagRegistry.g.cs", sb.ToString());
    }

    private static void GenerateTagAliases(SourceProductionContext context, int tagCount, string tagMaskType)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"// Tag count: {tagCount}");
        sb.AppendLine();
        sb.AppendLine($"global using TagMask = {tagMaskType};");

        context.AddSource("TagAliases.g.cs", sb.ToString());
    }

    private static void GenerateEntityTagsComponent(SourceProductionContext context, string rootNamespace, string tagMaskType, bool isUserDefined)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {rootNamespace};");
        sb.AppendLine();

        if (isUserDefined)
        {
            // User-defined EntityTags: generate partial struct with only IEntityTags interface
            sb.AppendLine("/// <summary>Partial implementation adding IEntityTags interface to user-defined EntityTags.</summary>");
            sb.AppendLine($"partial struct EntityTags : global::Paradise.ECS.IEntityTags<{tagMaskType}>");
            sb.AppendLine("{");
            sb.AppendLine($"    private {tagMaskType} _mask;");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>The tag bitmask for this entity.</summary>");
            sb.AppendLine($"    public {tagMaskType} Mask {{ get => _mask; set => _mask = value; }}");
            sb.AppendLine("}");
        }
        else
        {
            // Auto-generated EntityTags: generate complete struct
            sb.AppendLine("/// <summary>Component that stores entity tag bitmask. Auto-generated when tags are present.</summary>");
            sb.AppendLine($"public struct EntityTags : global::Paradise.ECS.IComponent, global::Paradise.ECS.IEntityTags<{tagMaskType}>");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>The unique component type ID assigned at module initialization.</summary>");
            sb.AppendLine("    public static global::Paradise.ECS.ComponentId TypeId { get; internal set; } = global::Paradise.ECS.ComponentId.Invalid;");
            sb.AppendLine();
            sb.AppendLine("    /// <summary>The stable GUID for this component type.</summary>");
            sb.AppendLine("    public static global::System.Guid Guid => global::System.Guid.Empty;");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>The size of this component in bytes.</summary>");
            sb.AppendLine($"    public static int Size {{ get; }} = global::System.Runtime.CompilerServices.Unsafe.SizeOf<{tagMaskType}>();");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>The alignment of this component in bytes.</summary>");
            sb.AppendLine($"    public static int Alignment {{ get; }} = global::Paradise.ECS.Memory.AlignOf<{tagMaskType}>();");
            sb.AppendLine();
            sb.AppendLine($"    private {tagMaskType} _mask;");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>The tag bitmask for this entity.</summary>");
            sb.AppendLine($"    public {tagMaskType} Mask {{ get => _mask; set => _mask = value; }}");
            sb.AppendLine("}");
        }

        context.AddSource("EntityTags.g.cs", sb.ToString());
    }

    private readonly struct TagGeneratorConfig
    {
        public string RootNamespace { get; }

        public TagGeneratorConfig(string rootNamespace)
        {
            RootNamespace = rootNamespace;
        }
    }
}
