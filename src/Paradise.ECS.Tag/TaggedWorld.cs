using System.Runtime.CompilerServices;

namespace Paradise.ECS;

/// <summary>
/// Diagnostic information about stale bits in chunk tag masks.
/// </summary>
/// <remarks>
/// <para>
/// Stale bits occur when tags are removed from entities but the chunk mask retains the bit
/// (sticky mask optimization). This optimization avoids expensive O(n) scans on every tag
/// removal, but can accumulate false-positive bits over time.
/// </para>
/// <para>
/// <b>Query Performance Impact:</b> Each stale bit causes tag queries to potentially check
/// chunks that no longer contain matching entities. For example, if a chunk mask has 3 stale
/// bits for tag A, B, C but no entities actually have those tags, queries for A, B, or C will
/// still examine this chunk before filtering at the entity level.
/// </para>
/// </remarks>
/// <param name="TotalChunks">Total number of chunks analyzed.</param>
/// <param name="ChunksWithStaleBits">Number of chunks that have at least one stale bit.</param>
/// <param name="TotalStaleBits">Total count of stale bits across all chunks.</param>
/// <param name="TotalActualBits">Total count of actual (non-stale) tag bits across all chunks.</param>
public readonly record struct StaleBitStatistics(
    int TotalChunks,
    int ChunksWithStaleBits,
    int TotalStaleBits,
    int TotalActualBits)
{
    /// <summary>
    /// Gets the ratio of stale bits to total bits (stale + actual).
    /// Returns 0 if there are no bits at all.
    /// </summary>
    /// <remarks>
    /// A ratio above 0.5 indicates that more than half the chunk mask bits are stale,
    /// which may warrant calling <c>RebuildChunkMasks()</c>.
    /// </remarks>
    public double StaleBitRatio => TotalStaleBits + TotalActualBits == 0
        ? 0
        : (double)TotalStaleBits / (TotalStaleBits + TotalActualBits);

    /// <summary>
    /// Gets the ratio of chunks with stale bits to total chunks.
    /// Returns 0 if there are no chunks.
    /// </summary>
    public double ChunksWithStaleBitsRatio => TotalChunks == 0
        ? 0
        : (double)ChunksWithStaleBits / TotalChunks;

    /// <summary>
    /// Gets whether the stale bit accumulation suggests rebuilding chunk masks.
    /// Returns true when <see cref="StaleBitRatio"/> exceeds 0.5 or more than 25% of chunks have stale bits.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <b>When to Rebuild:</b> Consider calling <c>RebuildChunkMasks()</c> when:
    /// <list type="bullet">
    /// <item><description><see cref="StaleBitRatio"/> exceeds 0.5 (50% of bits are stale)</description></item>
    /// <item><description><see cref="ChunksWithStaleBits"/> is significant relative to total chunks</description></item>
    /// <item><description>Tag query performance degrades noticeably</description></item>
    /// </list>
    /// </para>
    /// </remarks>
    public bool SuggestsRebuild => StaleBitRatio > 0.5 || ChunksWithStaleBitsRatio > 0.25;
}

/// <summary>
/// A world wrapper that provides tag support for entities.
/// Tags are stored as a component (EntityTags) that is automatically added to spawned entities.
/// </summary>
/// <typeparam name="TMask">The component mask type implementing IBitSet.</typeparam>
/// <typeparam name="TConfig">The world configuration type.</typeparam>
/// <typeparam name="TEntityTags">The EntityTags component type (generated by TagGenerator).</typeparam>
/// <typeparam name="TTagMask">The tag mask type (generated by TagGenerator as TagMask alias).</typeparam>
/// <remarks>
/// TaggedWorld wraps a standard World and adds tag-specific APIs.
/// Tags are stored in a per-entity bitmask component, enabling O(1) tag operations
/// without archetype changes.
/// </remarks>
public sealed class TaggedWorld<TMask, TConfig, TEntityTags, TTagMask>
    where TMask : unmanaged, IBitSet<TMask>
    where TConfig : IConfig, new()
    where TEntityTags : unmanaged, IComponent, IEntityTags<TTagMask>
    where TTagMask : unmanaged, IBitSet<TTagMask>
{
    private readonly World<TMask, TConfig> _world;
    private readonly ChunkTagRegistry<TTagMask> _chunkTagRegistry;

    /// <summary>
    /// Creates a new TaggedWorld with externally provided subsystems.
    /// The caller is responsible for disposing the provided resources.
    /// </summary>
    /// <param name="config">The configuration instance with runtime settings.</param>
    /// <param name="chunkManager">The chunk manager for memory allocation.</param>
    /// <param name="sharedMetadata">The shared archetype metadata.</param>
    /// <param name="chunkTagRegistry">The chunk tag registry for per-chunk tag filtering.</param>
    public TaggedWorld(
        TConfig config,
        ChunkManager chunkManager,
        SharedArchetypeMetadata<TMask, TConfig> sharedMetadata,
        ChunkTagRegistry<TTagMask> chunkTagRegistry)
    {
        _chunkTagRegistry = chunkTagRegistry;
        _world = new World<TMask, TConfig>(config, sharedMetadata, chunkManager);
    }

    /// <summary>
    /// Gets the underlying World instance.
    /// </summary>
    public World<TMask, TConfig> World => _world;

    /// <summary>
    /// Gets the archetype registry for this world.
    /// </summary>
    public ArchetypeRegistry<TMask, TConfig> ArchetypeRegistry => _world.ArchetypeRegistry;

    /// <summary>
    /// Gets the chunk tag registry for per-chunk tag filtering.
    /// </summary>
    public ChunkTagRegistry<TTagMask> ChunkTagRegistry => _chunkTagRegistry;

    /// <summary>
    /// Gets the current number of live entities.
    /// </summary>
    public int EntityCount => _world.EntityCount;

    /// <summary>
    /// Spawns a new entity with the EntityTags component automatically added.
    /// </summary>
    /// <returns>The newly created entity.</returns>
    public Entity Spawn()
    {
        var entity = _world.Spawn();
        _world.AddComponent<TEntityTags>(entity, default);
        return entity;
    }

    /// <summary>
    /// Despawns an entity, removing it from the world.
    /// </summary>
    /// <param name="entity">The entity to despawn.</param>
    /// <returns>True if the entity was despawned; false if it was already dead.</returns>
    /// <remarks>
    /// The chunk tag mask is not recomputed immediately (sticky mask optimization).
    /// Call <see cref="RebuildChunkMasks"/> to clean up stale bits if needed.
    /// </remarks>
    public bool Despawn(Entity entity)
    {
        if (!_world.IsAlive(entity))
            return false;

        // Despawn the entity - chunk mask not recomputed (sticky mask optimization)
        _world.Despawn(entity);
        return true;
    }

    /// <summary>
    /// Clears all entities from the world.
    /// Also clears all chunk tag masks.
    /// </summary>
    public void Clear()
    {
        _world.Clear();
    }

    /// <summary>
    /// Computes statistics about stale bits in chunk tag masks.
    /// Use this to monitor whether <see cref="RebuildChunkMasks"/> should be called.
    /// </summary>
    /// <returns>A <see cref="StaleBitStatistics"/> containing diagnostic information.</returns>
    /// <remarks>
    /// <para>
    /// Stale bits occur when tags are removed from entities but the chunk mask retains the bit
    /// (sticky mask optimization). While this doesn't affect correctness, it can degrade query
    /// performance by causing false-positive chunk matches.
    /// </para>
    /// <para>
    /// This operation is O(n) where n is the total number of entities. Use sparingly in
    /// performance-critical code paths.
    /// </para>
    /// </remarks>
    public StaleBitStatistics ComputeStaleBitStatistics()
    {
        int totalChunks = 0;
        int totalStaleBits = 0;
        int totalActualBits = 0;
        int chunksWithStaleBits = 0;

        for (int index = 0; index < _world.Archetypes.Count; index++)
        {
            Archetype<TMask, TConfig>? archetype = _world.Archetypes[index];
            if (archetype is null || !archetype.Layout.ComponentMask.Get(TEntityTags.TypeId.Value))
                continue;

            int chunkCount = archetype.ChunkCount;
            for (int chunkIndex = 0; chunkIndex < chunkCount; chunkIndex++)
            {
                var chunkHandle = archetype.GetChunk(chunkIndex);
                var currentMask = _chunkTagRegistry.GetChunkMask(chunkHandle);
                var actualMask = ComputeActualChunkMask(archetype, chunkIndex);

                int currentBits = currentMask.PopCount();
                int actualBits = actualMask.PopCount();
                int staleBits = currentBits - actualBits;

                totalChunks++;
                totalStaleBits += staleBits;
                totalActualBits += actualBits;
                if (staleBits > 0)
                    chunksWithStaleBits++;
            }
        }

        return new StaleBitStatistics(totalChunks, chunksWithStaleBits, totalStaleBits, totalActualBits);
    }

    /// <summary>
    /// Rebuilds all chunk tag masks by scanning all entities.
    /// Call this to clean up stale bits after tag removals or despawns.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This operation is O(n) where n is the total number of entities.
    /// Best called at natural breakpoints (level transitions, loading screens).
    /// </para>
    /// <para>
    /// <b>Performance Impact of Stale Bits:</b> Stale bits cause tag queries to check chunks
    /// that no longer contain matching entities. For workloads with frequent tag removals,
    /// consider calling this method periodically or when <see cref="ComputeStaleBitStatistics"/>
    /// shows high stale bit counts.
    /// </para>
    /// </remarks>
    public void RebuildChunkMasks()
    {
        // Clear all existing masks
        _chunkTagRegistry.Clear();

        // Iterate all archetypes that have EntityTags component
        for (int index = 0; index < _world.Archetypes.Count; index++)
        {
            Archetype<TMask, TConfig>? archetype = _world.Archetypes[index];
            if (archetype is null || !archetype.Layout.ComponentMask.Get(TEntityTags.TypeId.Value))
                continue;

            int chunkCount = archetype.ChunkCount;
            for (int chunkIndex = 0; chunkIndex < chunkCount; chunkIndex++)
            {
                var chunkHandle = archetype.GetChunk(chunkIndex);
                RecomputeChunkMask(chunkHandle, archetype, chunkIndex);
            }
        }
    }

    /// <summary>
    /// Checks if an entity is still alive.
    /// </summary>
    /// <param name="entity">The entity to check.</param>
    /// <returns>True if the entity is alive.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool IsAlive(Entity entity) => _world.IsAlive(entity);

    /// <summary>
    /// Adds a tag to an entity.
    /// </summary>
    /// <typeparam name="TTag">The tag type to add.</typeparam>
    /// <param name="entity">The entity to add the tag to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        // TODO: use mutable tag mask?
        tags.Mask = tags.Mask.Set(TTag.TagId);

        // Update chunk tag mask (OR the tag bit into the chunk's mask)
        var tagBit = default(TTagMask).Set(TTag.TagId);
        var chunkHandle = GetEntityChunkHandle(entity);
        _chunkTagRegistry.OrChunkMask(chunkHandle, tagBit);
    }

    /// <summary>
    /// Removes a tag from an entity.
    /// </summary>
    /// <typeparam name="TTag">The tag type to remove.</typeparam>
    /// <param name="entity">The entity to remove the tag from.</param>
    /// <remarks>
    /// The chunk tag mask is not recomputed immediately (sticky mask optimization).
    /// This may result in false positives during tag queries, which is safe but may
    /// cause queries to check a few extra entities. Call <see cref="RebuildChunkMasks"/>
    /// to clean up stale bits if needed.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        // TODO: use mutable tag mask?
        tags.Mask = tags.Mask.Clear(TTag.TagId);
        // Chunk mask not recomputed (sticky mask) - may have stale bits
    }

    /// <summary>
    /// Checks if an entity has a specific tag.
    /// </summary>
    /// <typeparam name="TTag">The tag type to check.</typeparam>
    /// <param name="entity">The entity to check.</param>
    /// <returns>True if the entity has the tag.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasTag<TTag>(Entity entity) where TTag : ITag
    {
        ref var tags = ref _world.GetComponentRef<TEntityTags>(entity);
        return tags.Mask.Get(TTag.TagId);
    }

    /// <summary>
    /// Gets the full tag mask for an entity.
    /// </summary>
    /// <param name="entity">The entity to get tags from.</param>
    /// <returns>The tag mask.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TTagMask GetTags(Entity entity)
    {
        return _world.GetComponent<TEntityTags>(entity).Mask;
    }

    /// <summary>
    /// Sets the full tag mask for an entity.
    /// </summary>
    /// <param name="entity">The entity to set tags on.</param>
    /// <param name="tags">The tag mask to set.</param>
    /// <remarks>
    /// When tags are removed, the chunk tag mask is not recomputed (sticky mask optimization).
    /// Call <see cref="RebuildChunkMasks"/> to clean up stale bits if needed.
    /// </remarks>
    public void SetTags(Entity entity, TTagMask tags)
    {
        ref var entityTags = ref _world.GetComponentRef<TEntityTags>(entity);
        var oldMask = entityTags.Mask;
        entityTags.Mask = tags;

        // Only update chunk mask for added tags (sticky mask optimization)
        var addedTags = tags.AndNot(oldMask); // tags in new but not in old

        if (!addedTags.Equals(default(TTagMask)))
        {
            var chunkHandle = GetEntityChunkHandle(entity);
            _chunkTagRegistry.OrChunkMask(chunkHandle, addedTags);
        }
        // Removed tags: chunk mask not recomputed (sticky) - may have stale bits
    }

    /// <summary>
    /// Gets a component value from an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T GetComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.GetComponent<T>(entity);

    /// <summary>
    /// Gets a reference to a component on an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ref T GetComponentRef<T>(Entity entity) where T : unmanaged, IComponent
        => ref _world.GetComponentRef<T>(entity);

    /// <summary>
    /// Sets a component value on an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void SetComponent<T>(Entity entity, T value) where T : unmanaged, IComponent
        => _world.SetComponent(entity, value);

    /// <summary>
    /// Checks if an entity has a component.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool HasComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.HasComponent<T>(entity);

    /// <summary>
    /// Adds a component to an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddComponent<T>(Entity entity, T value = default) where T : unmanaged, IComponent
        => _world.AddComponent(entity, value);

    /// <summary>
    /// Removes a component from an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveComponent<T>(Entity entity) where T : unmanaged, IComponent
        => _world.RemoveComponent<T>(entity);

    /// <summary>
    /// Creates a new query builder bound to this world.
    /// Use this for building tag-filtered queries with a clean API.
    /// </summary>
    /// <returns>A query builder bound to this world's type parameters.</returns>
    /// <example>
    /// <code>
    /// // Clean API - only specify the tag type
    /// var query = world.Query().WithTag&lt;EnemyTag&gt;().With&lt;Position&gt;().Build();
    /// foreach (var entity in query) { ... }
    /// </code>
    /// </example>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TaggedWorldQueryBuilder<TMask, TConfig, TEntityTags, TTagMask> Query()
        => new(this);

    /// <summary>
    /// Gets the chunk handle for an entity.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ChunkHandle GetEntityChunkHandle(Entity entity)
    {
        var location = _world.GetLocation(entity);
        var archetype = _world.ArchetypeRegistry.GetById(location.ArchetypeId)!;
        var (chunkIndex, _) = archetype.GetChunkLocation(location.GlobalIndex);
        return archetype.GetChunk(chunkIndex);
    }

    /// <summary>
    /// Recomputes the chunk tag mask by OR-ing all entity tag masks in the chunk.
    /// </summary>
    /// <param name="chunkHandle">The chunk handle.</param>
    /// <param name="archetype">The archetype containing the chunk.</param>
    /// <param name="chunkIndex">The chunk index within the archetype.</param>
    private void RecomputeChunkMask(ChunkHandle chunkHandle, Archetype<TMask, TConfig> archetype, int chunkIndex)
    {
        var newMask = ComputeActualChunkMask(archetype, chunkIndex);
        _chunkTagRegistry.SetChunkMask(chunkHandle, newMask);
    }

    /// <summary>
    /// Computes the actual tag mask for a chunk by OR-ing all entity tag masks.
    /// </summary>
    /// <param name="archetype">The archetype containing the chunk.</param>
    /// <param name="chunkIndex">The chunk index within the archetype.</param>
    /// <returns>The computed tag mask representing the union of all entity tags in the chunk.</returns>
    private TTagMask ComputeActualChunkMask(Archetype<TMask, TConfig> archetype, int chunkIndex)
    {
        var mask = default(TTagMask);

        // Calculate how many entities are in this specific chunk
        int entitiesPerChunk = archetype.Layout.EntitiesPerChunk;
        int totalEntities = archetype.EntityCount;
        int entityCountInChunk;

        if ((chunkIndex + 1) * entitiesPerChunk <= totalEntities)
        {
            // Full chunk
            entityCountInChunk = entitiesPerChunk;
        }
        else
        {
            // Last chunk (partially filled)
            entityCountInChunk = totalEntities - chunkIndex * entitiesPerChunk;
        }

        if (entityCountInChunk <= 0)
            return mask;

        // Get chunk data and compute union of all entity tag masks
        var chunkHandle = archetype.GetChunk(chunkIndex);
        var bytes = _world.ChunkManager.GetBytes(chunkHandle);
        int baseOffset = archetype.Layout.GetBaseOffset(TEntityTags.TypeId);
        int entityTagsSize = _world.TypeInfos[TEntityTags.TypeId.Value].Size;

        for (int i = 0; i < entityCountInChunk; i++)
        {
            ref var entityTags = ref bytes.GetRef<TEntityTags>(baseOffset + i * entityTagsSize);
            mask = mask.Or(entityTags.Mask);
        }

        return mask;
    }
}

/// <summary>
/// Extension methods for building queries in a TaggedWorld.
/// </summary>
public static class QueryBuilderTaggedWorldExtensions
{
    extension<TMask>(QueryBuilder<TMask> builder) where TMask : unmanaged, IBitSet<TMask>
    {
        /// <summary>
        /// Builds a WorldQuery from this description for a TaggedWorld.
        /// Delegates to the underlying World.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WorldQuery<TMask, TConfig> Build<TConfig, TEntityTags, TTagMask>(
            TaggedWorld<TMask, TConfig, TEntityTags, TTagMask> taggedWorld)
            where TConfig : IConfig, new()
            where TEntityTags : unmanaged, IComponent, IEntityTags<TTagMask>
            where TTagMask : unmanaged, IBitSet<TTagMask>
        {
            return builder.Build(taggedWorld.World);
        }

        /// <summary>
        /// Builds a WorldChunkQuery from this description for a TaggedWorld.
        /// Delegates to the underlying World.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WorldChunkQuery<TMask, TConfig> BuildChunk<TConfig, TEntityTags, TTagMask>(
            TaggedWorld<TMask, TConfig, TEntityTags, TTagMask> taggedWorld)
            where TConfig : IConfig, new()
            where TEntityTags : unmanaged, IComponent, IEntityTags<TTagMask>
            where TTagMask : unmanaged, IBitSet<TTagMask>
        {
            return builder.BuildChunk(taggedWorld.World);
        }
    }
}

