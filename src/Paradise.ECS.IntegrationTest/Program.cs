using System.Diagnostics;
using Paradise.ECS.IntegrationTest;

// The 'World' type alias is generated by the source generator.
// Without [DefaultConfig], it uses Paradise.ECS.DefaultConfig as fallback.
// It resolves to: World<Bit64, ComponentRegistry, DefaultConfig>

Console.WriteLine("=== Paradise.ECS Integration Test ===");
Console.WriteLine();

// Create shared resources
using var sharedMetadata = new SharedArchetypeMetadata();
using var chunkManager = DefaultChunkManager.Create();

// Create the world using the generated World alias
var world = new World(sharedMetadata, chunkManager);

Console.WriteLine("1. Testing Entity Creation");
Console.WriteLine("----------------------------");

// Spawn empty entity
var emptyEntity = world.Spawn();
Console.WriteLine($"  Created empty entity: {emptyEntity}");
Console.WriteLine($"  Entity count: {world.EntityCount}");
Debug.Assert(world.EntityCount == 1);
Debug.Assert(world.IsAlive(emptyEntity));

// Create player entity with components using builder
var playerEntity = EntityBuilder.Create()
    .Add(new Position(100, 200))
    .Add(new Velocity(5, 0))
    .Add(new Health(100))
    .Add(default(PlayerTag))
    .Add(new Name("Hero"))
    .Build(world);
Console.WriteLine($"  Created player entity: {playerEntity}");
Console.WriteLine($"  Entity count: {world.EntityCount}");
Debug.Assert(world.EntityCount == 2);
Debug.Assert(world.IsAlive(playerEntity));

// Create multiple enemy entities
var enemies = new Entity[5];
for (int i = 0; i < enemies.Length; i++)
{
    enemies[i] = EntityBuilder.Create()
        .Add(new Position(i * 50, 300))
        .Add(new Velocity(-2, 0))
        .Add(new Health(50))
        .Add(default(EnemyTag))
        .Build(world);
}
Console.WriteLine($"  Created {enemies.Length} enemy entities");
Console.WriteLine($"  Entity count: {world.EntityCount}");
Debug.Assert(world.EntityCount == 7); // 1 empty + 1 player + 5 enemies
Console.WriteLine();

Console.WriteLine("2. Testing Component Access");
Console.WriteLine("----------------------------");

// Read components
var playerPos = world.GetComponent<Position>(playerEntity);
var playerHealth = world.GetComponent<Health>(playerEntity);
var playerName = world.GetComponent<Name>(playerEntity);
Console.WriteLine($"  Player position: {playerPos}");
Console.WriteLine($"  Player health: {playerHealth}");
Console.WriteLine($"  Player name: {playerName}");
Debug.Assert(playerPos.X == 100 && playerPos.Y == 200);
Debug.Assert(playerHealth.Current == 100 && playerHealth.Max == 100);
Debug.Assert(playerName.ToString() == "Hero");

// Modify component
world.SetComponent(playerEntity, new Position(150, 250));
playerPos = world.GetComponent<Position>(playerEntity);
Console.WriteLine($"  Updated player position: {playerPos}");
Debug.Assert(playerPos.X == 150 && playerPos.Y == 250);

// Check for components
Console.WriteLine($"  Player has Position: {world.HasComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has PlayerTag: {world.HasComponent<PlayerTag>(playerEntity)}");
Console.WriteLine($"  Player has EnemyTag: {world.HasComponent<EnemyTag>(playerEntity)}");
Debug.Assert(world.HasComponent<Position>(playerEntity));
Debug.Assert(world.HasComponent<PlayerTag>(playerEntity));
Debug.Assert(!world.HasComponent<EnemyTag>(playerEntity));
Console.WriteLine();

Console.WriteLine("3. Testing Structural Changes");
Console.WriteLine("----------------------------");

// Add component to empty entity
world.AddComponent(emptyEntity, new Position(0, 0));
Console.WriteLine($"  Added Position to empty entity");
Console.WriteLine($"  Empty entity has Position: {world.HasComponent<Position>(emptyEntity)}");
Debug.Assert(world.HasComponent<Position>(emptyEntity));

// Remove component
world.RemoveComponent<Position>(emptyEntity);
Console.WriteLine($"  Removed Position from entity");
Console.WriteLine($"  Entity has Position: {world.HasComponent<Position>(emptyEntity)}");
Debug.Assert(!world.HasComponent<Position>(emptyEntity));
Console.WriteLine();

Console.WriteLine("4. Testing Entity Lifecycle");
Console.WriteLine("----------------------------");

Console.WriteLine($"  Entity count before despawn: {world.EntityCount}");
Console.WriteLine($"  Enemy[0] is alive: {world.IsAlive(enemies[0])}");
Debug.Assert(world.EntityCount == 7);
Debug.Assert(world.IsAlive(enemies[0]));

// Despawn an enemy
world.Despawn(enemies[0]);
Console.WriteLine($"  Despawned enemy[0]");
Console.WriteLine($"  Enemy[0] is alive: {world.IsAlive(enemies[0])}");
Console.WriteLine($"  Entity count after despawn: {world.EntityCount}");
Debug.Assert(!world.IsAlive(enemies[0]));
Debug.Assert(world.EntityCount == 6);

// Try to despawn again (should return false)
var despawnedAgain = world.Despawn(enemies[0]);
Console.WriteLine($"  Despawn enemy[0] again: {despawnedAgain}");
Debug.Assert(!despawnedAgain);
Console.WriteLine();

Console.WriteLine("5. Simulating Game Loop (5 frames)");
Console.WriteLine("----------------------------");

// Create a query for movable entities using WorldQuery (returns WorldEntity)
var movableWorldQuery = QueryBuilder
    .Create()
    .With<Position>()
    .With<Velocity>()
    .Build(world);

// Simple movement system simulation using WorldEntity
for (int frame = 0; frame < 5; frame++)
{
    Console.WriteLine($"  Frame {frame + 1}:");

    int movedEntities = 0;
    foreach (var entity in movableWorldQuery)
    {
        // Use WorldEntity's convenient Get method (returns ref)
        ref var pos = ref entity.Get<Position>();
        var vel = entity.Get<Velocity>();
        pos = new Position(pos.X + vel.X, pos.Y + vel.Y);
        movedEntities++;

        // Check if this is the player
        if (entity.Has<PlayerTag>())
        {
            Console.WriteLine($"    Player moved to {pos}");
        }
    }
    Console.WriteLine($"    Moved {movedEntities} entities total");
}
Console.WriteLine();

Console.WriteLine("6. Testing Query Enumerators");
Console.WriteLine("----------------------------");

// WorldQuery API - iterates WorldEntity with convenient Get/Set/Has methods
Console.WriteLine("  WorldQuery API (Build with World):");
Console.WriteLine($"    EntityCount: {movableWorldQuery.EntityCount}");
Console.WriteLine($"    IsEmpty: {movableWorldQuery.IsEmpty}");
Debug.Assert(movableWorldQuery.EntityCount == 5); // player + 4 enemies (1 despawned)
Debug.Assert(!movableWorldQuery.IsEmpty);

Console.WriteLine("  Iterating over WorldEntity:");
foreach (var entity in movableWorldQuery)
{
    var pos = entity.Get<Position>();
    var isPlayer = entity.Has<PlayerTag>();
    Console.WriteLine($"    Entity {entity.Entity.Id}: Position={pos}, IsPlayer={isPlayer}");
}

// Access underlying Query for low-level iteration
var underlyingQuery = movableWorldQuery.Query;
Console.WriteLine($"  Underlying Query - ArchetypeCount: {underlyingQuery.ArchetypeCount}");

// Iterate over entity IDs using underlying Query
Console.WriteLine("  Iterating over entity IDs (underlying Query):");
var entityIdList = new List<int>();
foreach (var entityId in underlyingQuery)
{
    entityIdList.Add(entityId);
}
Console.WriteLine($"    Found {entityIdList.Count} entity IDs: [{string.Join(", ", entityIdList)}]");

// Iterate over archetypes using Archetypes property
Console.WriteLine("  Iterating over archetypes:");
foreach (var archetype in underlyingQuery.Archetypes)
{
    Console.WriteLine($"    Archetype {archetype.Id}: {archetype.EntityCount} entities, {archetype.ChunkCount} chunks");
}

// Iterate over chunks using Chunks enumerator
Console.WriteLine("  Iterating over chunks:");
foreach (var chunkInfo in underlyingQuery.Chunks)
{
    Console.WriteLine($"    Chunk from archetype {chunkInfo.Archetype.Id}: {chunkInfo.EntityCount} entities");
}

// Query with exclusion filter using WorldQuery
var nonPlayerMovableQuery = QueryBuilder
    .Create()
    .With<Position>()
    .With<Velocity>()
    .Without<PlayerTag>()
    .Build(world);

Console.WriteLine($"  Query for movable non-players:");
Console.WriteLine($"    EntityCount: {nonPlayerMovableQuery.EntityCount}");
Debug.Assert(nonPlayerMovableQuery.EntityCount == 4); // 4 enemies (1 despawned)
foreach (var entity in nonPlayerMovableQuery)
{
    Console.WriteLine($"    Enemy at {entity.Get<Position>()}");
}

// Query with Health using WorldQuery
var healthQuery = QueryBuilder
    .Create()
    .With<Health>()
    .Build(world);

Console.WriteLine($"  Query for entities with Health:");
Console.WriteLine($"    EntityCount: {healthQuery.EntityCount}");
Debug.Assert(healthQuery.EntityCount == 5); // player + 4 enemies
foreach (var entity in healthQuery)
{
    Console.WriteLine($"    Entity {entity.Entity.Id} health: {entity.Get<Health>()}");
}
Console.WriteLine();

Console.WriteLine("7. Testing Entity Overwrite");
Console.WriteLine("----------------------------");

// Overwrite player with completely new components
Console.WriteLine($"  Player before overwrite - Position: {world.GetComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has Velocity: {world.HasComponent<Velocity>(playerEntity)}");
Debug.Assert(world.HasComponent<Velocity>(playerEntity));

EntityBuilder.Create()
    .Add(new Position(0, 0))
    .Add(new Health(200))
    .Add(default(PlayerTag))
    .Overwrite(playerEntity, world);

Console.WriteLine($"  Player after overwrite - Position: {world.GetComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has Velocity: {world.HasComponent<Velocity>(playerEntity)}");
Console.WriteLine($"  Player health: {world.GetComponent<Health>(playerEntity)}");
var overwrittenPos = world.GetComponent<Position>(playerEntity);
var overwrittenHealth = world.GetComponent<Health>(playerEntity);
Debug.Assert(overwrittenPos.X == 0 && overwrittenPos.Y == 0);
Debug.Assert(!world.HasComponent<Velocity>(playerEntity));
Debug.Assert(overwrittenHealth.Current == 200 && overwrittenHealth.Max == 200);
Console.WriteLine();

Console.WriteLine("8. Testing World Clear");
Console.WriteLine("----------------------------");

Console.WriteLine($"  Entity count before clear: {world.EntityCount}");
Debug.Assert(world.EntityCount == 6); // 1 empty + 4 enemies + 1 player (overwritten)
world.Clear();
Console.WriteLine($"  World cleared");
Console.WriteLine($"  Entity count after clear: {world.EntityCount}");
Console.WriteLine($"  Player is alive after clear: {world.IsAlive(playerEntity)}");
Debug.Assert(world.EntityCount == 0);
Debug.Assert(!world.IsAlive(playerEntity));
Console.WriteLine();

Console.WriteLine("9. Testing Queryable Iteration");
Console.WriteLine("----------------------------");

// Re-create world and entities for this test
var world2 = new World(sharedMetadata, chunkManager);

// Create diverse test entities to demonstrate all query patterns
Console.WriteLine("  Creating test entities...");

// Player with velocity (matches Player, Movable, Positioned, Damageable queries)
var playerWithVel = EntityBuilder.Create()
    .Add(new Position(10, 20))
    .Add(new Velocity(1, 2))
    .Add(new Health(100))
    .Add(default(PlayerTag))
    .Build(world2);
Console.WriteLine($"    Player with velocity: Entity {playerWithVel.Id}");
Debug.Assert(world2.IsAlive(playerWithVel));

// Player without velocity (matches Player, Positioned, Damageable, but NOT Movable)
var playerNoVel = EntityBuilder.Create()
    .Add(new Position(30, 40))
    .Add(new Health(80))
    .Add(default(PlayerTag))
    .Build(world2);
Console.WriteLine($"    Player without velocity: Entity {playerNoVel.Id}");
Debug.Assert(world2.IsAlive(playerNoVel));

// Named player (excluded from Player query due to Without<Name>)
var namedPlayer = EntityBuilder.Create()
    .Add(new Position(50, 60))
    .Add(new Health(90))
    .Add(default(PlayerTag))
    .Add(new Name("Hero"))
    .Build(world2);
Console.WriteLine($"    Named player (excluded from Player query): Entity {namedPlayer.Id}");
Debug.Assert(world2.IsAlive(namedPlayer));

// Moving enemy with velocity (matches Enemy due to Any<Velocity>)
var movingEnemy = EntityBuilder.Create()
    .Add(new Position(100, 110))
    .Add(new Velocity(3, 4))
    .Add(new Health(50))
    .Add(default(EnemyTag))
    .Build(world2);
Console.WriteLine($"    Moving enemy: Entity {movingEnemy.Id}");
Debug.Assert(world2.IsAlive(movingEnemy));

// Stationary enemy without velocity (does NOT match Enemy due to Any<Velocity>)
var stationaryEnemy = EntityBuilder.Create()
    .Add(new Position(120, 130))
    .Add(new Health(40))
    .Add(default(EnemyTag))
    .Build(world2);
Console.WriteLine($"    Stationary enemy (no velocity, excluded from Enemy): Entity {stationaryEnemy.Id}");
Debug.Assert(world2.IsAlive(stationaryEnemy));

// Health-only entity (matches Damageable, but not Positioned)
var healthOnly = EntityBuilder.Create()
    .Add(new Health(25))
    .Build(world2);
Console.WriteLine($"    Health-only entity: Entity {healthOnly.Id}");
Debug.Assert(world2.IsAlive(healthOnly));

Console.WriteLine($"  Total entities: {world2.EntityCount}");
Debug.Assert(world2.EntityCount == 6);
Console.WriteLine();

// ============================================================================
// Demo 1: Player.Query - Custom names, IsReadOnly, Optional components
// ============================================================================
Console.WriteLine("  [Demo 1] Player.Query - Custom names, IsReadOnly, Optional<Velocity>");
Console.WriteLine("  Definition: [With<Position>][With<Health>(Name=\"Hp\", IsReadOnly=true)][Without<Name>][Optional<Velocity>]");
var playerQuery = Player.Query.Build(world2);
Console.WriteLine($"    EntityCount: {playerQuery.EntityCount} (excludes named player)");
Debug.Assert(playerQuery.EntityCount == 4); // 2 players + moving enemy + stationary enemy (all have Position+Health, no Name)

foreach (var p in playerQuery)
{
    Console.WriteLine($"    ---");
    // Direct property access for Position (read-write)
    Console.WriteLine($"    Position: {p.Position}");
    p.Position = new Position(p.Position.X + 100, p.Position.Y + 100);
    Console.WriteLine($"    Position after +100: {p.Position}");

    // Custom property name "Hp" for Health (read-only)
    Console.WriteLine($"    Hp (read-only): {p.Hp.Current}/{p.Hp.Max}");

    // Optional<Velocity> - HasVelocity property + GetVelocity() method
    Console.WriteLine($"    HasVelocity: {p.HasVelocity}");
    if (p.HasVelocity)
    {
        ref var vel = ref p.GetVelocity();
        Console.WriteLine($"    Velocity: ({vel.X}, {vel.Y})");
        vel.X *= 2;
        Console.WriteLine($"    Velocity after *2: ({vel.X}, {vel.Y})");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 2: Enemy.Query - Any<T> constraint
// ============================================================================
Console.WriteLine("  [Demo 2] Enemy.Query - Any<Velocity> constraint");
Console.WriteLine("  Definition: [With<Position>][With<Health>][Without<Name>][Any<Velocity>]");
var enemyQuery = Enemy.Query.Build(world2);
Console.WriteLine($"    EntityCount: {enemyQuery.EntityCount} (only enemies WITH velocity)");
Debug.Assert(enemyQuery.EntityCount == 2); // playerWithVel + movingEnemy (entities with Velocity)

foreach (var e in enemyQuery)
{
    Console.WriteLine($"    Enemy at {e.Position}, health: {e.Health}");
}
Console.WriteLine();

// ============================================================================
// Demo 3: PlayerPosition.Query - QueryOnly filter
// ============================================================================
Console.WriteLine("  [Demo 3] PlayerPosition.Query - QueryOnly filter");
Console.WriteLine("  Definition: [With<Position>][With<PlayerTag>(QueryOnly=true)]");
var playerPosQuery = PlayerPosition.Query.Build(world2);
Console.WriteLine($"    EntityCount: {playerPosQuery.EntityCount} (all entities with PlayerTag)");
Debug.Assert(playerPosQuery.EntityCount == 3); // playerWithVel + playerNoVel + namedPlayer

foreach (var pp in playerPosQuery)
{
    // Only Position property available - PlayerTag is QueryOnly (no property generated)
    Console.WriteLine($"    Player position: {pp.Position}");
}
Console.WriteLine();

// ============================================================================
// Demo 4: Movable.Query - Simple two-component query
// ============================================================================
Console.WriteLine("  [Demo 4] Movable.Query - Simple required components");
Console.WriteLine("  Definition: [With<Position>][With<Velocity>]");
var movableQuery = Movable.Query.Build(world2);
Console.WriteLine($"    EntityCount: {movableQuery.EntityCount} (entities with BOTH Position AND Velocity)");
Debug.Assert(movableQuery.EntityCount == 2); // playerWithVel + movingEnemy

foreach (var m in movableQuery)
{
    Console.WriteLine($"    Movable at {m.Position} with velocity ({m.Velocity.X}, {m.Velocity.Y})");
}
Console.WriteLine();

// ============================================================================
// Demo 5: Damageable.Query - Optional with IsReadOnly
// ============================================================================
Console.WriteLine("  [Demo 5] Damageable.Query - Optional<Position>(IsReadOnly=true)");
Console.WriteLine("  Definition: [With<Health>][Optional<Position>(IsReadOnly=true)]");
var damageableQuery = Damageable.Query.Build(world2);
Console.WriteLine($"    EntityCount: {damageableQuery.EntityCount} (all entities with Health)");
Debug.Assert(damageableQuery.EntityCount == 6); // all 6 entities have Health

foreach (var d in damageableQuery)
{
    Console.Write($"    Health: {d.Health}");
    if (d.HasPosition)
    {
        // GetPosition() returns ref readonly due to IsReadOnly=true
        ref readonly var pos = ref d.GetPosition();
        Console.WriteLine($" at position {pos}");
    }
    else
    {
        Console.WriteLine(" (no position)");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 6: NamedEntity.Query - With<Name> component
// ============================================================================
Console.WriteLine("  [Demo 6] NamedEntity.Query - Entities with Name");
Console.WriteLine("  Definition: [With<Position>][With<Name>]");
var namedQuery = NamedEntity.Query.Build(world2);
Console.WriteLine($"    EntityCount: {namedQuery.EntityCount}");
Debug.Assert(namedQuery.EntityCount == 1); // only namedPlayer has Name

foreach (var n in namedQuery)
{
    Console.WriteLine($"    '{n.Name}' at {n.Position}");
}
Console.WriteLine();

// ============================================================================
// Demo 7: Positioned.Query - Minimal broad query
// ============================================================================
Console.WriteLine("  [Demo 7] Positioned.Query - All positioned entities");
Console.WriteLine("  Definition: [With<Position>]");
var positionedQuery = Positioned.Query.Build(world2);
Console.WriteLine($"    EntityCount: {positionedQuery.EntityCount}");
Debug.Assert(positionedQuery.EntityCount == 5); // all except healthOnly

foreach (var p in positionedQuery)
{
    Console.WriteLine($"    Position: {p.Position}");
}
Console.WriteLine();

// ============================================================================
// Demo 8: Game loop pattern - Movement system using Movable.Query
// ============================================================================
Console.WriteLine("  [Demo 8] Game Loop Pattern - Movement system");
Console.WriteLine("  Simulating 3 frames of movement...");

for (int frame = 0; frame < 3; frame++)
{
    Console.WriteLine($"    Frame {frame + 1}:");
    var moveQuery = Movable.Query.Build(world2);

    // Skip iteration if no entities (efficient pattern)
    if (moveQuery.IsEmpty)
    {
        Console.WriteLine($"      No movable entities");
        continue;
    }

    foreach (var entity in moveQuery)
    {
        var oldPos = entity.Position;
        entity.Position = new Position(
            entity.Position.X + entity.Velocity.X,
            entity.Position.Y + entity.Velocity.Y);
        Console.WriteLine($"      Moved from {oldPos} to {entity.Position}");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 9: Damage system using Damageable.Query
// ============================================================================
Console.WriteLine("  [Demo 9] Damage System - Apply damage to all damageable entities");
{
    var dmgQuery = Damageable.Query.Build(world2);
    Console.WriteLine($"    Applying 10 damage to {dmgQuery.EntityCount} entities...");

    foreach (var d in dmgQuery)
    {
        // Health property is read-write in Damageable query
        var oldHealth = d.Health.Current;
        d.Health = new Health(d.Health.Max) { Current = Math.Max(0, d.Health.Current - 10) };
        Console.WriteLine($"      Health: {oldHealth} -> {d.Health.Current}");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 10: Query reuse pattern
// ============================================================================
Console.WriteLine("  [Demo 10] Query Reuse - Multiple iterations over same query");
{
    var query = Positioned.Query.Build(world2);
    Console.WriteLine($"    First pass (count positions):");
    int count = 0;
    foreach (var _ in query)
    {
        count++;
    }
    Console.WriteLine($"      Counted {count} positioned entities");

    Console.WriteLine($"    Second pass (sum X coordinates):");
    float sumX = 0;
    foreach (var p in query)
    {
        sumX += p.Position.X;
    }
    Console.WriteLine($"      Sum of X: {sumX}");
}
Console.WriteLine();

// ============================================================================
// Demo 11: WorldChunkQuery - Chunk-level batch processing
// ============================================================================
Console.WriteLine("  [Demo 11] WorldChunkQuery - Chunk-level batch processing");
Console.WriteLine("  Usage: QueryBuilder.BuildChunk(world) returns WorldChunkQuery for batch component access");
{
    // BuildChunk returns WorldChunkQuery for batch processing
    var chunkQuery = QueryBuilder.Create()
        .With<Position>()
        .With<Health>()
        .BuildChunk(world2);

    Console.WriteLine($"    EntityCount: {chunkQuery.EntityCount}");
    Console.WriteLine($"    Iterating over chunks:");

    int chunkIndex = 0;
    foreach (var chunk in chunkQuery)
    {
        Console.WriteLine($"      Chunk {chunkIndex++}: {chunk.EntityCount} entities");

        // Check if chunk has specific component
        Console.WriteLine($"        Has<Position>: {chunk.Has<Position>()}");
        Console.WriteLine($"        Has<Velocity>: {chunk.Has<Velocity>()}");

        // Batch processing with GetSpan - efficient SIMD-friendly access
        var positions = chunk.GetSpan<Position>();
        var healths = chunk.GetSpan<Health>();

        Console.WriteLine($"        Processing {positions.Length} positions:");
        for (int i = 0; i < positions.Length; i++)
        {
            Console.WriteLine($"          [{i}] Position={positions[i]}, Health={healths[i].Current}/{healths[i].Max}");
        }

        // TryGetSpan for optional components
        if (chunk.TryGetSpan<Velocity>(out var velocities))
        {
            Console.WriteLine($"        Found {velocities.Length} velocities in this chunk");
        }
        else
        {
            Console.WriteLine($"        No Velocity component in this chunk's archetype");
        }
    }
}
Console.WriteLine();

// ============================================================================
// Demo 12: Player.ChunkQuery - Type-safe chunk-level batch processing
// ============================================================================
Console.WriteLine("  [Demo 12] Player.ChunkQuery - Type-safe batch component access");
Console.WriteLine("  Usage: Player.ChunkQuery.Build(world) returns typed chunk query with span properties");
{
    var playerChunkQuery = Player.ChunkQuery.Build(world2);
    Console.WriteLine($"    EntityCount: {playerChunkQuery.EntityCount}");
    Debug.Assert(playerChunkQuery.EntityCount == 4); // Same as Player.Query (excludes named player)
    Console.WriteLine($"    Iterating over chunks with typed accessors:");

    int chunkIndex = 0;
    int totalEntitiesProcessed = 0;
    foreach (var chunk in playerChunkQuery)
    {
        Console.WriteLine($"      Chunk {chunkIndex++}: {chunk.EntityCount} entities");
        Debug.Assert(chunk.EntityCount > 0);

        // Type-safe span accessors via generated properties (pluralized names)
        Span<Position> positions = chunk.Positions;
        ReadOnlySpan<Health> hps = chunk.Hps;  // ReadOnly because [With<Health>(IsReadOnly = true)]

        // Verify span lengths match entity count
        Debug.Assert(positions.Length == chunk.EntityCount);
        Debug.Assert(hps.Length == chunk.EntityCount);

        Console.WriteLine($"        Processing {positions.Length} entities:");
        for (int i = 0; i < positions.Length; i++)
        {
            Console.WriteLine($"          [{i}] Position={positions[i]}, Hp={hps[i].Current}/{hps[i].Max}");
            var oldPos = positions[i];
            // Batch modify positions
            positions[i] = new Position(positions[i].X + 1000, positions[i].Y + 1000);
            Debug.Assert(positions[i].X == oldPos.X + 1000);
            Debug.Assert(positions[i].Y == oldPos.Y + 1000);
        }

        // Optional component - HasVelocity property + GetVelocitys() method
        Console.WriteLine($"        HasVelocity: {chunk.HasVelocity}");
        if (chunk.HasVelocity)
        {
            var velocities = chunk.GetVelocitys();
            Debug.Assert(velocities.Length == chunk.EntityCount);
            Console.WriteLine($"        Found {velocities.Length} velocities:");
            for (int i = 0; i < velocities.Length; i++)
            {
                Console.WriteLine($"          [{i}] Velocity=({velocities[i].X}, {velocities[i].Y})");
            }
        }

        totalEntitiesProcessed += chunk.EntityCount;
    }
    Debug.Assert(totalEntitiesProcessed == playerChunkQuery.EntityCount);

    // Verify batch modifications persisted
    Console.WriteLine($"    Verifying batch position updates:");
    int verifiedCount = 0;
    foreach (var p in Player.Query.Build(world2))
    {
        Console.WriteLine($"      Position after +1000: {p.Position}");
        Debug.Assert(p.Position.X >= 1000); // All positions should have been increased by 1000
        verifiedCount++;
    }
    Debug.Assert(verifiedCount == 4);
}
Console.WriteLine();

Console.WriteLine("10. Verifying Generated Types");
Console.WriteLine("----------------------------");

// Verify the ComponentMask alias works
Console.WriteLine($"  ComponentMask type: {typeof(ComponentMask).FullName}");

// Verify the World alias works
Console.WriteLine($"  World type: {typeof(World).FullName}");

// Verify component type IDs are assigned
Console.WriteLine($"  Position.TypeId: {Position.TypeId}");
Console.WriteLine($"  Velocity.TypeId: {Velocity.TypeId}");
Console.WriteLine($"  Health.TypeId: {Health.TypeId}");
Console.WriteLine($"  PlayerTag.TypeId: {PlayerTag.TypeId}");
Console.WriteLine($"  EnemyTag.TypeId: {EnemyTag.TypeId}");
Console.WriteLine($"  Name.TypeId: {Name.TypeId}");

// Verify component GUIDs
Console.WriteLine($"  Position.Guid: {Position.Guid}");
Console.WriteLine($"  PlayerTag.Guid: {PlayerTag.Guid}");

// Verify component sizes
Console.WriteLine($"  Position.Size: {Position.Size} bytes");
Console.WriteLine($"  Health.Size: {Health.Size} bytes");
Console.WriteLine($"  PlayerTag.Size: {PlayerTag.Size} bytes (tag component)");
Console.WriteLine($"  Name.Size: {Name.Size} bytes");

// Verify ComponentRegistry
Console.WriteLine($"  ComponentRegistry.TypeInfos.Length: {ComponentRegistry.TypeInfos.Length}");
Console.WriteLine();

Console.WriteLine("=== Integration Test Complete ===");
Console.WriteLine("All operations executed successfully!");

return 0;
