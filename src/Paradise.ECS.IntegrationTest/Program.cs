using Paradise.ECS.IntegrationTest;

// The 'World' type alias is generated by the source generator.
// Without [DefaultConfig], it uses Paradise.ECS.DefaultConfig as fallback.
// It resolves to: World<Bit64, ComponentRegistry, DefaultConfig>

Console.WriteLine("=== Paradise.ECS Integration Test ===");
Console.WriteLine();

// Create shared resources
using var sharedMetadata = new SharedArchetypeMetadata();
using var chunkManager = DefaultChunkManager.Create();

// Create the world using the generated World alias
var world = new World(sharedMetadata, chunkManager);

Console.WriteLine("1. Testing Entity Creation");
Console.WriteLine("----------------------------");

// Spawn empty entity
var emptyEntity = world.Spawn();
Console.WriteLine($"  Created empty entity: {emptyEntity}");
Console.WriteLine($"  Entity count: {world.EntityCount}");

// Create player entity with components using builder
var playerEntity = EntityBuilder.Create()
    .Add(new Position(100, 200))
    .Add(new Velocity(5, 0))
    .Add(new Health(100))
    .Add(default(PlayerTag))
    .Add(new Name("Hero"))
    .Build(world);
Console.WriteLine($"  Created player entity: {playerEntity}");
Console.WriteLine($"  Entity count: {world.EntityCount}");

// Create multiple enemy entities
var enemies = new Entity[5];
for (int i = 0; i < enemies.Length; i++)
{
    enemies[i] = EntityBuilder.Create()
        .Add(new Position(i * 50, 300))
        .Add(new Velocity(-2, 0))
        .Add(new Health(50))
        .Add(default(EnemyTag))
        .Build(world);
}
Console.WriteLine($"  Created {enemies.Length} enemy entities");
Console.WriteLine($"  Entity count: {world.EntityCount}");
Console.WriteLine();

Console.WriteLine("2. Testing Component Access");
Console.WriteLine("----------------------------");

// Read components
var playerPos = world.GetComponent<Position>(playerEntity);
var playerHealth = world.GetComponent<Health>(playerEntity);
var playerName = world.GetComponent<Name>(playerEntity);
Console.WriteLine($"  Player position: {playerPos}");
Console.WriteLine($"  Player health: {playerHealth}");
Console.WriteLine($"  Player name: {playerName}");

// Modify component
world.SetComponent(playerEntity, new Position(150, 250));
playerPos = world.GetComponent<Position>(playerEntity);
Console.WriteLine($"  Updated player position: {playerPos}");

// Check for components
Console.WriteLine($"  Player has Position: {world.HasComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has PlayerTag: {world.HasComponent<PlayerTag>(playerEntity)}");
Console.WriteLine($"  Player has EnemyTag: {world.HasComponent<EnemyTag>(playerEntity)}");
Console.WriteLine();

Console.WriteLine("3. Testing Structural Changes");
Console.WriteLine("----------------------------");

// Add component to empty entity
world.AddComponent(emptyEntity, new Position(0, 0));
Console.WriteLine($"  Added Position to empty entity");
Console.WriteLine($"  Empty entity has Position: {world.HasComponent<Position>(emptyEntity)}");

// Remove component
world.RemoveComponent<Position>(emptyEntity);
Console.WriteLine($"  Removed Position from entity");
Console.WriteLine($"  Entity has Position: {world.HasComponent<Position>(emptyEntity)}");
Console.WriteLine();

Console.WriteLine("4. Testing Entity Lifecycle");
Console.WriteLine("----------------------------");

Console.WriteLine($"  Entity count before despawn: {world.EntityCount}");
Console.WriteLine($"  Enemy[0] is alive: {world.IsAlive(enemies[0])}");

// Despawn an enemy
world.Despawn(enemies[0]);
Console.WriteLine($"  Despawned enemy[0]");
Console.WriteLine($"  Enemy[0] is alive: {world.IsAlive(enemies[0])}");
Console.WriteLine($"  Entity count after despawn: {world.EntityCount}");

// Try to despawn again (should return false)
var despawnedAgain = world.Despawn(enemies[0]);
Console.WriteLine($"  Despawn enemy[0] again: {despawnedAgain}");
Console.WriteLine();

Console.WriteLine("5. Simulating Game Loop (5 frames)");
Console.WriteLine("----------------------------");

// Create a query for movable entities using WorldQuery (returns WorldEntity)
var movableWorldQuery = QueryBuilder
    .Create()
    .With<Position>()
    .With<Velocity>()
    .Build(world);

// Simple movement system simulation using WorldEntity
for (int frame = 0; frame < 5; frame++)
{
    Console.WriteLine($"  Frame {frame + 1}:");

    int movedEntities = 0;
    foreach (var entity in movableWorldQuery)
    {
        // Use WorldEntity's convenient Get method (returns ref)
        ref var pos = ref entity.Get<Position>();
        var vel = entity.Get<Velocity>();
        pos = new Position(pos.X + vel.X, pos.Y + vel.Y);
        movedEntities++;

        // Check if this is the player
        if (entity.Has<PlayerTag>())
        {
            Console.WriteLine($"    Player moved to {pos}");
        }
    }
    Console.WriteLine($"    Moved {movedEntities} entities total");
}
Console.WriteLine();

Console.WriteLine("6. Testing Query Enumerators");
Console.WriteLine("----------------------------");

// WorldQuery API - iterates WorldEntity with convenient Get/Set/Has methods
Console.WriteLine("  WorldQuery API (Build with World):");
Console.WriteLine($"    EntityCount: {movableWorldQuery.EntityCount}");
Console.WriteLine($"    IsEmpty: {movableWorldQuery.IsEmpty}");

Console.WriteLine("  Iterating over WorldEntity:");
foreach (var entity in movableWorldQuery)
{
    var pos = entity.Get<Position>();
    var isPlayer = entity.Has<PlayerTag>();
    Console.WriteLine($"    Entity {entity.Entity.Id}: Position={pos}, IsPlayer={isPlayer}");
}

// Access underlying Query for low-level iteration
var underlyingQuery = movableWorldQuery.Query;
Console.WriteLine($"  Underlying Query - ArchetypeCount: {underlyingQuery.ArchetypeCount}");

// Iterate over entity IDs using underlying Query
Console.WriteLine("  Iterating over entity IDs (underlying Query):");
var entityIdList = new List<int>();
foreach (var entityId in underlyingQuery)
{
    entityIdList.Add(entityId);
}
Console.WriteLine($"    Found {entityIdList.Count} entity IDs: [{string.Join(", ", entityIdList)}]");

// Iterate over archetypes using Archetypes property
Console.WriteLine("  Iterating over archetypes:");
foreach (var archetype in underlyingQuery.Archetypes)
{
    Console.WriteLine($"    Archetype {archetype.Id}: {archetype.EntityCount} entities, {archetype.ChunkCount} chunks");
}

// Iterate over chunks using Chunks enumerator
Console.WriteLine("  Iterating over chunks:");
foreach (var chunkInfo in underlyingQuery.Chunks)
{
    Console.WriteLine($"    Chunk from archetype {chunkInfo.Archetype.Id}: {chunkInfo.EntityCount} entities");
}

// Query with exclusion filter using WorldQuery
var nonPlayerMovableQuery = QueryBuilder
    .Create()
    .With<Position>()
    .With<Velocity>()
    .Without<PlayerTag>()
    .Build(world);

Console.WriteLine($"  Query for movable non-players:");
Console.WriteLine($"    EntityCount: {nonPlayerMovableQuery.EntityCount}");
foreach (var entity in nonPlayerMovableQuery)
{
    Console.WriteLine($"    Enemy at {entity.Get<Position>()}");
}

// Query with Health using WorldQuery
var healthQuery = QueryBuilder
    .Create()
    .With<Health>()
    .Build(world);

Console.WriteLine($"  Query for entities with Health:");
Console.WriteLine($"    EntityCount: {healthQuery.EntityCount}");
foreach (var entity in healthQuery)
{
    Console.WriteLine($"    Entity {entity.Entity.Id} health: {entity.Get<Health>()}");
}
Console.WriteLine();

Console.WriteLine("7. Testing Entity Overwrite");
Console.WriteLine("----------------------------");

// Overwrite player with completely new components
Console.WriteLine($"  Player before overwrite - Position: {world.GetComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has Velocity: {world.HasComponent<Velocity>(playerEntity)}");

EntityBuilder.Create()
    .Add(new Position(0, 0))
    .Add(new Health(200))
    .Add(default(PlayerTag))
    .Overwrite(playerEntity, world);

Console.WriteLine($"  Player after overwrite - Position: {world.GetComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has Velocity: {world.HasComponent<Velocity>(playerEntity)}");
Console.WriteLine($"  Player health: {world.GetComponent<Health>(playerEntity)}");
Console.WriteLine();

Console.WriteLine("8. Testing World Clear");
Console.WriteLine("----------------------------");

Console.WriteLine($"  Entity count before clear: {world.EntityCount}");
world.Clear();
Console.WriteLine($"  World cleared");
Console.WriteLine($"  Entity count after clear: {world.EntityCount}");
Console.WriteLine($"  Player is alive after clear: {world.IsAlive(playerEntity)}");
Console.WriteLine();

Console.WriteLine("9. Verifying Generated Types");
Console.WriteLine("----------------------------");

// Verify the ComponentMask alias works
Console.WriteLine($"  ComponentMask type: {typeof(ComponentMask).FullName}");

// Verify the World alias works
Console.WriteLine($"  World type: {typeof(World).FullName}");

// Verify component type IDs are assigned
Console.WriteLine($"  Position.TypeId: {Position.TypeId}");
Console.WriteLine($"  Velocity.TypeId: {Velocity.TypeId}");
Console.WriteLine($"  Health.TypeId: {Health.TypeId}");
Console.WriteLine($"  PlayerTag.TypeId: {PlayerTag.TypeId}");
Console.WriteLine($"  EnemyTag.TypeId: {EnemyTag.TypeId}");
Console.WriteLine($"  Name.TypeId: {Name.TypeId}");

// Verify component GUIDs
Console.WriteLine($"  Position.Guid: {Position.Guid}");
Console.WriteLine($"  PlayerTag.Guid: {PlayerTag.Guid}");

// Verify component sizes
Console.WriteLine($"  Position.Size: {Position.Size} bytes");
Console.WriteLine($"  Health.Size: {Health.Size} bytes");
Console.WriteLine($"  PlayerTag.Size: {PlayerTag.Size} bytes (tag component)");
Console.WriteLine($"  Name.Size: {Name.Size} bytes");

// Verify ComponentRegistry
Console.WriteLine($"  ComponentRegistry.TypeInfos.Length: {ComponentRegistry.TypeInfos.Length}");
Console.WriteLine();

Console.WriteLine("=== Integration Test Complete ===");
Console.WriteLine("All operations executed successfully!");

return 0;
