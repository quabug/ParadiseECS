using Paradise.ECS.IntegrationTest;

// The 'World' type alias is generated by the source generator.
// Without [DefaultConfig], it uses Paradise.ECS.DefaultConfig as fallback.
// It resolves to: World<Bit64, ComponentRegistry, DefaultConfig>

Console.WriteLine("=== Paradise.ECS Integration Test ===");
Console.WriteLine();

// Create shared resources
using var sharedMetadata = new SharedArchetypeMetadata();
using var chunkManager = DefaultChunkManager.Create();

// Create the world using the generated World alias
var world = new World(sharedMetadata, chunkManager);

Console.WriteLine("1. Testing Entity Creation");
Console.WriteLine("----------------------------");

// Spawn empty entity
var emptyEntity = world.Spawn();
Console.WriteLine($"  Created empty entity: {emptyEntity}");
Console.WriteLine($"  Entity count: {world.EntityCount}");

// Create player entity with components using builder
var playerEntity = EntityBuilder.Create()
    .Add(new Position(100, 200))
    .Add(new Velocity(5, 0))
    .Add(new Health(100))
    .Add(default(PlayerTag))
    .Add(new Name("Hero"))
    .Build(world);
Console.WriteLine($"  Created player entity: {playerEntity}");
Console.WriteLine($"  Entity count: {world.EntityCount}");

// Create multiple enemy entities
var enemies = new Entity[5];
for (int i = 0; i < enemies.Length; i++)
{
    enemies[i] = EntityBuilder.Create()
        .Add(new Position(i * 50, 300))
        .Add(new Velocity(-2, 0))
        .Add(new Health(50))
        .Add(default(EnemyTag))
        .Build(world);
}
Console.WriteLine($"  Created {enemies.Length} enemy entities");
Console.WriteLine($"  Entity count: {world.EntityCount}");
Console.WriteLine();

Console.WriteLine("2. Testing Component Access");
Console.WriteLine("----------------------------");

// Read components
var playerPos = world.GetComponent<Position>(playerEntity);
var playerHealth = world.GetComponent<Health>(playerEntity);
var playerName = world.GetComponent<Name>(playerEntity);
Console.WriteLine($"  Player position: {playerPos}");
Console.WriteLine($"  Player health: {playerHealth}");
Console.WriteLine($"  Player name: {playerName}");

// Modify component
world.SetComponent(playerEntity, new Position(150, 250));
playerPos = world.GetComponent<Position>(playerEntity);
Console.WriteLine($"  Updated player position: {playerPos}");

// Check for components
Console.WriteLine($"  Player has Position: {world.HasComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has PlayerTag: {world.HasComponent<PlayerTag>(playerEntity)}");
Console.WriteLine($"  Player has EnemyTag: {world.HasComponent<EnemyTag>(playerEntity)}");
Console.WriteLine();

Console.WriteLine("3. Testing Structural Changes");
Console.WriteLine("----------------------------");

// Add component to empty entity
world.AddComponent(emptyEntity, new Position(0, 0));
Console.WriteLine($"  Added Position to empty entity");
Console.WriteLine($"  Empty entity has Position: {world.HasComponent<Position>(emptyEntity)}");

// Remove component
world.RemoveComponent<Position>(emptyEntity);
Console.WriteLine($"  Removed Position from entity");
Console.WriteLine($"  Entity has Position: {world.HasComponent<Position>(emptyEntity)}");
Console.WriteLine();

Console.WriteLine("4. Testing Entity Lifecycle");
Console.WriteLine("----------------------------");

Console.WriteLine($"  Entity count before despawn: {world.EntityCount}");
Console.WriteLine($"  Enemy[0] is alive: {world.IsAlive(enemies[0])}");

// Despawn an enemy
world.Despawn(enemies[0]);
Console.WriteLine($"  Despawned enemy[0]");
Console.WriteLine($"  Enemy[0] is alive: {world.IsAlive(enemies[0])}");
Console.WriteLine($"  Entity count after despawn: {world.EntityCount}");

// Try to despawn again (should return false)
var despawnedAgain = world.Despawn(enemies[0]);
Console.WriteLine($"  Despawn enemy[0] again: {despawnedAgain}");
Console.WriteLine();

Console.WriteLine("5. Simulating Game Loop (5 frames)");
Console.WriteLine("----------------------------");

// Create a query for movable entities using WorldQuery (returns WorldEntity)
var movableWorldQuery = QueryBuilder
    .Create()
    .With<Position>()
    .With<Velocity>()
    .Build(world);

// Simple movement system simulation using WorldEntity
for (int frame = 0; frame < 5; frame++)
{
    Console.WriteLine($"  Frame {frame + 1}:");

    int movedEntities = 0;
    foreach (var entity in movableWorldQuery)
    {
        // Use WorldEntity's convenient Get method (returns ref)
        ref var pos = ref entity.Get<Position>();
        var vel = entity.Get<Velocity>();
        pos = new Position(pos.X + vel.X, pos.Y + vel.Y);
        movedEntities++;

        // Check if this is the player
        if (entity.Has<PlayerTag>())
        {
            Console.WriteLine($"    Player moved to {pos}");
        }
    }
    Console.WriteLine($"    Moved {movedEntities} entities total");
}
Console.WriteLine();

Console.WriteLine("6. Testing Query Enumerators");
Console.WriteLine("----------------------------");

// WorldQuery API - iterates WorldEntity with convenient Get/Set/Has methods
Console.WriteLine("  WorldQuery API (Build with World):");
Console.WriteLine($"    EntityCount: {movableWorldQuery.EntityCount}");
Console.WriteLine($"    IsEmpty: {movableWorldQuery.IsEmpty}");

Console.WriteLine("  Iterating over WorldEntity:");
foreach (var entity in movableWorldQuery)
{
    var pos = entity.Get<Position>();
    var isPlayer = entity.Has<PlayerTag>();
    Console.WriteLine($"    Entity {entity.Entity.Id}: Position={pos}, IsPlayer={isPlayer}");
}

// Access underlying Query for low-level iteration
var underlyingQuery = movableWorldQuery.Query;
Console.WriteLine($"  Underlying Query - ArchetypeCount: {underlyingQuery.ArchetypeCount}");

// Iterate over entity IDs using underlying Query
Console.WriteLine("  Iterating over entity IDs (underlying Query):");
var entityIdList = new List<int>();
foreach (var entityId in underlyingQuery)
{
    entityIdList.Add(entityId);
}
Console.WriteLine($"    Found {entityIdList.Count} entity IDs: [{string.Join(", ", entityIdList)}]");

// Iterate over archetypes using Archetypes property
Console.WriteLine("  Iterating over archetypes:");
foreach (var archetype in underlyingQuery.Archetypes)
{
    Console.WriteLine($"    Archetype {archetype.Id}: {archetype.EntityCount} entities, {archetype.ChunkCount} chunks");
}

// Iterate over chunks using Chunks enumerator
Console.WriteLine("  Iterating over chunks:");
foreach (var chunkInfo in underlyingQuery.Chunks)
{
    Console.WriteLine($"    Chunk from archetype {chunkInfo.Archetype.Id}: {chunkInfo.EntityCount} entities");
}

// Query with exclusion filter using WorldQuery
var nonPlayerMovableQuery = QueryBuilder
    .Create()
    .With<Position>()
    .With<Velocity>()
    .Without<PlayerTag>()
    .Build(world);

Console.WriteLine($"  Query for movable non-players:");
Console.WriteLine($"    EntityCount: {nonPlayerMovableQuery.EntityCount}");
foreach (var entity in nonPlayerMovableQuery)
{
    Console.WriteLine($"    Enemy at {entity.Get<Position>()}");
}

// Query with Health using WorldQuery
var healthQuery = QueryBuilder
    .Create()
    .With<Health>()
    .Build(world);

Console.WriteLine($"  Query for entities with Health:");
Console.WriteLine($"    EntityCount: {healthQuery.EntityCount}");
foreach (var entity in healthQuery)
{
    Console.WriteLine($"    Entity {entity.Entity.Id} health: {entity.Get<Health>()}");
}
Console.WriteLine();

Console.WriteLine("7. Testing Entity Overwrite");
Console.WriteLine("----------------------------");

// Overwrite player with completely new components
Console.WriteLine($"  Player before overwrite - Position: {world.GetComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has Velocity: {world.HasComponent<Velocity>(playerEntity)}");

EntityBuilder.Create()
    .Add(new Position(0, 0))
    .Add(new Health(200))
    .Add(default(PlayerTag))
    .Overwrite(playerEntity, world);

Console.WriteLine($"  Player after overwrite - Position: {world.GetComponent<Position>(playerEntity)}");
Console.WriteLine($"  Player has Velocity: {world.HasComponent<Velocity>(playerEntity)}");
Console.WriteLine($"  Player health: {world.GetComponent<Health>(playerEntity)}");
Console.WriteLine();

Console.WriteLine("8. Testing World Clear");
Console.WriteLine("----------------------------");

Console.WriteLine($"  Entity count before clear: {world.EntityCount}");
world.Clear();
Console.WriteLine($"  World cleared");
Console.WriteLine($"  Entity count after clear: {world.EntityCount}");
Console.WriteLine($"  Player is alive after clear: {world.IsAlive(playerEntity)}");
Console.WriteLine();

Console.WriteLine("9. Testing KGP-style Queryable Iteration");
Console.WriteLine("----------------------------");

// Re-create world and entities for this test
var world2 = new World(sharedMetadata, chunkManager);

// Create diverse test entities to demonstrate all query patterns
Console.WriteLine("  Creating test entities...");

// Player with velocity (matches Player, Movable, Positioned, Damageable queries)
var playerWithVel = EntityBuilder.Create()
    .Add(new Position(10, 20))
    .Add(new Velocity(1, 2))
    .Add(new Health(100))
    .Add(default(PlayerTag))
    .Build(world2);
Console.WriteLine($"    Player with velocity: Entity {playerWithVel.Id}");

// Player without velocity (matches Player, Positioned, Damageable, but NOT Movable)
var playerNoVel = EntityBuilder.Create()
    .Add(new Position(30, 40))
    .Add(new Health(80))
    .Add(default(PlayerTag))
    .Build(world2);
Console.WriteLine($"    Player without velocity: Entity {playerNoVel.Id}");

// Named player (excluded from Player query due to Without<Name>)
var namedPlayer = EntityBuilder.Create()
    .Add(new Position(50, 60))
    .Add(new Health(90))
    .Add(default(PlayerTag))
    .Add(new Name("Hero"))
    .Build(world2);
Console.WriteLine($"    Named player (excluded from Player query): Entity {namedPlayer.Id}");

// Moving enemy with velocity (matches Enemy due to Any<Velocity>)
var movingEnemy = EntityBuilder.Create()
    .Add(new Position(100, 110))
    .Add(new Velocity(3, 4))
    .Add(new Health(50))
    .Add(default(EnemyTag))
    .Build(world2);
Console.WriteLine($"    Moving enemy: Entity {movingEnemy.Id}");

// Stationary enemy without velocity (does NOT match Enemy due to Any<Velocity>)
var stationaryEnemy = EntityBuilder.Create()
    .Add(new Position(120, 130))
    .Add(new Health(40))
    .Add(default(EnemyTag))
    .Build(world2);
Console.WriteLine($"    Stationary enemy (no velocity, excluded from Enemy): Entity {stationaryEnemy.Id}");

// Health-only entity (matches Damageable, but not Positioned)
var healthOnly = EntityBuilder.Create()
    .Add(new Health(25))
    .Build(world2);
Console.WriteLine($"    Health-only entity: Entity {healthOnly.Id}");

Console.WriteLine($"  Total entities: {world2.EntityCount}");
Console.WriteLine();

// ============================================================================
// Demo 1: Player.Query - Custom names, IsReadOnly, Optional components
// ============================================================================
Console.WriteLine("  [Demo 1] Player.Query - Custom names, IsReadOnly, Optional<Velocity>");
Console.WriteLine("  Definition: [With<Position>][With<Health>(Name=\"Hp\", IsReadOnly=true)][Without<Name>][Optional<Velocity>]");
var playerQuery = Player.Query.Build(world2);
Console.WriteLine($"    EntityCount: {playerQuery.EntityCount} (excludes named player)");

foreach (var p in playerQuery)
{
    Console.WriteLine($"    ---");
    // Direct property access for Position (read-write)
    Console.WriteLine($"    Position: {p.Position}");
    p.Position = new Position(p.Position.X + 100, p.Position.Y + 100);
    Console.WriteLine($"    Position after +100: {p.Position}");

    // Custom property name "Hp" for Health (read-only)
    Console.WriteLine($"    Hp (read-only): {p.Hp.Current}/{p.Hp.Max}");

    // Optional<Velocity> - HasVelocity property + GetVelocity() method
    Console.WriteLine($"    HasVelocity: {p.HasVelocity}");
    if (p.HasVelocity)
    {
        ref var vel = ref p.GetVelocity();
        Console.WriteLine($"    Velocity: ({vel.X}, {vel.Y})");
        vel.X *= 2;
        Console.WriteLine($"    Velocity after *2: ({vel.X}, {vel.Y})");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 2: Enemy.Query - Any<T> constraint
// ============================================================================
Console.WriteLine("  [Demo 2] Enemy.Query - Any<Velocity> constraint");
Console.WriteLine("  Definition: [With<Position>][With<Health>][Without<Name>][Any<Velocity>]");
var enemyQuery = Enemy.Query.Build(world2);
Console.WriteLine($"    EntityCount: {enemyQuery.EntityCount} (only enemies WITH velocity)");

foreach (var e in enemyQuery)
{
    Console.WriteLine($"    Enemy at {e.Position}, health: {e.Health}");
}
Console.WriteLine();

// ============================================================================
// Demo 3: PlayerPosition.Query - QueryOnly filter
// ============================================================================
Console.WriteLine("  [Demo 3] PlayerPosition.Query - QueryOnly filter");
Console.WriteLine("  Definition: [With<Position>][With<PlayerTag>(QueryOnly=true)]");
var playerPosQuery = PlayerPosition.Query.Build(world2);
Console.WriteLine($"    EntityCount: {playerPosQuery.EntityCount} (all entities with PlayerTag)");

foreach (var pp in playerPosQuery)
{
    // Only Position property available - PlayerTag is QueryOnly (no property generated)
    Console.WriteLine($"    Player position: {pp.Position}");
}
Console.WriteLine();

// ============================================================================
// Demo 4: Movable.Query - Simple two-component query
// ============================================================================
Console.WriteLine("  [Demo 4] Movable.Query - Simple required components");
Console.WriteLine("  Definition: [With<Position>][With<Velocity>]");
var movableQuery = Movable.Query.Build(world2);
Console.WriteLine($"    EntityCount: {movableQuery.EntityCount} (entities with BOTH Position AND Velocity)");

foreach (var m in movableQuery)
{
    Console.WriteLine($"    Movable at {m.Position} with velocity ({m.Velocity.X}, {m.Velocity.Y})");
}
Console.WriteLine();

// ============================================================================
// Demo 5: Damageable.Query - Optional with IsReadOnly
// ============================================================================
Console.WriteLine("  [Demo 5] Damageable.Query - Optional<Position>(IsReadOnly=true)");
Console.WriteLine("  Definition: [With<Health>][Optional<Position>(IsReadOnly=true)]");
var damageableQuery = Damageable.Query.Build(world2);
Console.WriteLine($"    EntityCount: {damageableQuery.EntityCount} (all entities with Health)");

foreach (var d in damageableQuery)
{
    Console.Write($"    Health: {d.Health}");
    if (d.HasPosition)
    {
        // GetPosition() returns ref readonly due to IsReadOnly=true
        ref readonly var pos = ref d.GetPosition();
        Console.WriteLine($" at position {pos}");
    }
    else
    {
        Console.WriteLine(" (no position)");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 6: NamedEntity.Query - With<Name> component
// ============================================================================
Console.WriteLine("  [Demo 6] NamedEntity.Query - Entities with Name");
Console.WriteLine("  Definition: [With<Position>][With<Name>]");
var namedQuery = NamedEntity.Query.Build(world2);
Console.WriteLine($"    EntityCount: {namedQuery.EntityCount}");

foreach (var n in namedQuery)
{
    Console.WriteLine($"    '{n.Name}' at {n.Position}");
}
Console.WriteLine();

// ============================================================================
// Demo 7: Positioned.Query - Minimal broad query
// ============================================================================
Console.WriteLine("  [Demo 7] Positioned.Query - All positioned entities");
Console.WriteLine("  Definition: [With<Position>]");
var positionedQuery = Positioned.Query.Build(world2);
Console.WriteLine($"    EntityCount: {positionedQuery.EntityCount}");

foreach (var p in positionedQuery)
{
    Console.WriteLine($"    Position: {p.Position}");
}
Console.WriteLine();

// ============================================================================
// Demo 8: Game loop pattern - Movement system using Movable.Query
// ============================================================================
Console.WriteLine("  [Demo 8] Game Loop Pattern - Movement system");
Console.WriteLine("  Simulating 3 frames of movement...");

for (int frame = 0; frame < 3; frame++)
{
    Console.WriteLine($"    Frame {frame + 1}:");
    var moveQuery = Movable.Query.Build(world2);

    // Skip iteration if no entities (efficient pattern)
    if (moveQuery.IsEmpty)
    {
        Console.WriteLine($"      No movable entities");
        continue;
    }

    foreach (var entity in moveQuery)
    {
        var oldPos = entity.Position;
        entity.Position = new Position(
            entity.Position.X + entity.Velocity.X,
            entity.Position.Y + entity.Velocity.Y);
        Console.WriteLine($"      Moved from {oldPos} to {entity.Position}");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 9: Damage system using Damageable.Query
// ============================================================================
Console.WriteLine("  [Demo 9] Damage System - Apply damage to all damageable entities");
{
    var dmgQuery = Damageable.Query.Build(world2);
    Console.WriteLine($"    Applying 10 damage to {dmgQuery.EntityCount} entities...");

    foreach (var d in dmgQuery)
    {
        // Health property is read-write in Damageable query
        var oldHealth = d.Health.Current;
        d.Health = new Health(d.Health.Max) { Current = Math.Max(0, d.Health.Current - 10) };
        Console.WriteLine($"      Health: {oldHealth} -> {d.Health.Current}");
    }
}
Console.WriteLine();

// ============================================================================
// Demo 10: Query reuse pattern
// ============================================================================
Console.WriteLine("  [Demo 10] Query Reuse - Multiple iterations over same query");
{
    var query = Positioned.Query.Build(world2);
    Console.WriteLine($"    First pass (count positions):");
    int count = 0;
    foreach (var _ in query)
    {
        count++;
    }
    Console.WriteLine($"      Counted {count} positioned entities");

    Console.WriteLine($"    Second pass (sum X coordinates):");
    float sumX = 0;
    foreach (var p in query)
    {
        sumX += p.Position.X;
    }
    Console.WriteLine($"      Sum of X: {sumX}");
}
Console.WriteLine();

Console.WriteLine("10. Verifying Generated Types");
Console.WriteLine("----------------------------");

// Verify the ComponentMask alias works
Console.WriteLine($"  ComponentMask type: {typeof(ComponentMask).FullName}");

// Verify the World alias works
Console.WriteLine($"  World type: {typeof(World).FullName}");

// Verify component type IDs are assigned
Console.WriteLine($"  Position.TypeId: {Position.TypeId}");
Console.WriteLine($"  Velocity.TypeId: {Velocity.TypeId}");
Console.WriteLine($"  Health.TypeId: {Health.TypeId}");
Console.WriteLine($"  PlayerTag.TypeId: {PlayerTag.TypeId}");
Console.WriteLine($"  EnemyTag.TypeId: {EnemyTag.TypeId}");
Console.WriteLine($"  Name.TypeId: {Name.TypeId}");

// Verify component GUIDs
Console.WriteLine($"  Position.Guid: {Position.Guid}");
Console.WriteLine($"  PlayerTag.Guid: {PlayerTag.Guid}");

// Verify component sizes
Console.WriteLine($"  Position.Size: {Position.Size} bytes");
Console.WriteLine($"  Health.Size: {Health.Size} bytes");
Console.WriteLine($"  PlayerTag.Size: {PlayerTag.Size} bytes (tag component)");
Console.WriteLine($"  Name.Size: {Name.Size} bytes");

// Verify ComponentRegistry
Console.WriteLine($"  ComponentRegistry.TypeInfos.Length: {ComponentRegistry.TypeInfos.Length}");
Console.WriteLine();

Console.WriteLine("=== Integration Test Complete ===");
Console.WriteLine("All operations executed successfully!");

return 0;
